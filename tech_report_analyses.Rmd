---
title: "Technical Report Analyses"
author: "Marta Topor"
date: "11/04/2021"
output: word_document
---


```{r WD, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Set-up the workspace and load the data
setwd("~/All working docs/PhD/Tech Report/EasyCap_Mobita_Report")
library(tidyverse)
library(yarrr)
library(rstatix)
library(coin)

```


# Comparison of high and low frequecy noise in raw data  
  
The first part of analysis assesses the noise in the data before any preprocessing was applied. This information can be used to assess the quality of recorded data. We can especially pay attention to low frequency noise which may lead to drifts in the data and 50Hz noise which is an important indication of noise especially for Mobita where impedence could not be tested.  
  
******  
  
## **0.1-2Hz**    

```{r low freq, eval=TRUE, echo=FALSE}

df_raw_low <- read.csv("raw_2Hz_all.csv")
df_raw_low <- df_raw_low[,-c(1,2)]

#import Theta frequency data
# Select EasyCap data and log transform
E_chans_low <- as.data.frame(df_raw_low[1:28])
E_chans_low_log <- as.data.frame(lapply(E_chans_low, log))
E_chans_low_log$mean_E <- rowMeans(E_chans_low_log)

# Select Mobita data and log transform
M_chans_low <- as.data.frame(df_raw_low[29:56])
M_chans_low_log <- as.data.frame(lapply(M_chans_low, log))
M_chans_low_log$mean_M <- rowMeans(M_chans_low_log)

# put the means of both systems in one data frame to be used for plots
all_chans_low <- E_chans_low_log$mean_E
all_chans_low[11:20] <- M_chans_low_log$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_low <- as.data.frame(cbind(all_chans_low, group))
df_means_low$group <- as.factor(df_means_low$group)
```
  
**Results**  
  
- Pirate Plot, the box indicates the IQR and median 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Wilcoxon test result 
- Fligner-Killeen test for homogeneity of variance 
  
```{r low freq results, eval=TRUE, echo=FALSE, message=FALSE, message=FALSE}  
raw_low_median_e <- median(E_chans_low_log$mean_E)
raw_low_iqr_e <- IQR(E_chans_low_log$mean_E)

raw_low_median_m <- median(M_chans_low_log$mean_M)
raw_low_iqr_m <- IQR(M_chans_low_log$mean_M)

#Test of mean differences
raw_low_wil <- wilcox.test(E_chans_low_log$mean_E, M_chans_low_log$mean_M,paired=TRUE)

raw_low_es <- wilcox_effsize(df_means_low, all_chans_low ~ group, paired=TRUE)

#Test of homogeneity of variances
raw_low_flig <- fligner.test(all_chans_low ~ group, data = df_means_low)

#ggplot(df_means_low, aes(x=group, y=all_chans_low, fill=group)) +
 # geom_violin(trim = FALSE)+
  #geom_boxplot(width=0.1)+ #this is for median and IQR
  #geom_jitter(shape=16, position=position_jitter(0.2))+
  #theme_classic()


pirateplot(formula = all_chans_low~group, #which variables are you using
           data = df_means_low,
           theme = 0, 
           main = "0.1 - 2 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-1, 4, by = 1)) #set the numbers on the y axis

```

There is a significant difference in variance between EasyCap and Mobita for for the Fligner-Killeen test.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r raw_low_median_e`(`r raw_low_iqr_e`)  
**Median for Mobita:** `r raw_low_median_m`(`r raw_low_iqr_m`)  
  
**Wilcoxon:** V = `r raw_low_wil$statistic`, p = `r raw_low_wil$p.value`, Bonferroni p = `r raw_low_wil$p.value*8`, r = `r raw_low_es$effsize` (`r raw_low_es$magnitude`)    
  
**Fligner-Killeen:** X^2^ = `r raw_low_flig$statistic`, p = `r raw_low_flig$p.value`, Bonferroni p = `r raw_low_flig$p.value*8`  
  
******  
  
  

## **49-51Hz**    
  

```{r load raw high freq, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_raw_high <- read.csv("raw_50Hz_all.csv")

#remove participant info
df_raw_high <- df_raw_high[,-c(1,2)]

# Select EasyCap data and log transform
E_chans_high <- as.data.frame(df_raw_high[1:28])
E_chans_high_log <- as.data.frame(lapply(E_chans_high, log))
E_chans_high_log$mean_E <- rowMeans(E_chans_high_log)

# Select Mobita data and log transform
M_chans_high <- as.data.frame(df_raw_high[29:56])
M_chans_high_log <- as.data.frame(lapply(M_chans_high, log))
M_chans_high_log$mean_M <- rowMeans(M_chans_high_log)

# Put the means of both systems in one data frame to be used for plots
all_chans_high <- E_chans_high_log$mean_E
all_chans_high[11:20] <- M_chans_high_log$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_high <- as.data.frame(cbind(all_chans_high, group))
df_means_high$group <- as.factor(df_means_high$group)

```
  
**Descriptive statistics, Wilcoxon test and plot:**  
  
- Piate Plot with IQR and median 
- Median for EasyCap 
- Median for Mobita 
- Wilcoxon test result 
- Fligner-Killeen test 
    

```{r high freq results, eval=TRUE, echo=FALSE, message=FALSE}
raw_high_median_e <- median(E_chans_high_log$mean_E)
raw_high_iqr_e <- IQR(E_chans_high_log$mean_E)

raw_high_median_m <- median(M_chans_high_log$mean_M)
raw_high_iqr_m <- IQR(M_chans_high_log$mean_M)

#Test of mean differences
raw_high_wil <- wilcox.test(E_chans_high_log$mean_E, M_chans_high_log$mean_M,paired=TRUE)

raw_high_es <- wilcox_effsize(df_means_high, all_chans_high ~ group, paired=TRUE)
 
#Test of homogeneity of variances
raw_high_flig <- fligner.test(all_chans_high ~ group, data = df_means_high)

pirateplot(formula = all_chans_high~group, #which variables are you using
           data = df_means_high,
           theme = 0, 
           main = "49 - 51 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-9, -1, by = 1)) #set the numbers on the y axis


```
  
There is a significant difference in variance between EasyCap and Mobita for for the Fligner-Killeen test.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r raw_high_median_e`(`r raw_high_iqr_e`)    
**Median for Mobita:** `r raw_high_median_m`(`r raw_high_iqr_m`)  
  
**Wilcoxon:** V = `r raw_high_wil$statistic`, p = `r raw_high_wil$p.value`, Bonferroni p = `r raw_high_wil$p.value*8`, r = `r raw_high_es$effsize` (`r raw_high_es$magnitude`)    
  
**Fligner-Killeen:** X^2^ = `r raw_high_flig$statistic`, p = `r raw_high_flig$p.value`, Bonferroni p = `r raw_high_flig$p.value*8`  
  
******  
  
  
**Raw Freq Plot Log-Transformed 0-60Hz**  
  
![Raw_Freq](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\fig1_raw_freq.jpg)  
  
  
# 
# Comparison of noise during and after pre-processing  
In this part data will be analysed to compare artefacts which were removed during pre-processing. Then noise metrics SNR and RMS will be compared between the two systems. Lastly, 0.1-2Hz and 49-51Hz power will be compared between the systems again.  
  
******
  
```{r pre-proc data, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_preproc <- read.csv("pre_processing_data.csv")

```
  
## **0.1-2Hz**    

```{r low freq processed, eval=TRUE, echo=FALSE}

df_range_low_c <- read.csv("range_2Hz_all.csv")
df_range_low_c <- df_range_low_c[,-c(1,2)]

# Select EasyCap data and log transform
E_chans_low_c <- as.data.frame(df_range_low_c[1:28])
E_chans_low_log_c <- as.data.frame(lapply(E_chans_low_c, log))
E_chans_low_log_c$mean_E <- rowMeans(E_chans_low_log_c)

# Select Mobita data and log transform
M_chans_low_c <- as.data.frame(df_range_low_c[29:56])
M_chans_low_log_c <- as.data.frame(lapply(M_chans_low_c, log))
M_chans_low_log_c$mean_M <- rowMeans(M_chans_low_log_c)

# put the means of both systems in one data frame to be used for plots
all_chans_low_c <- E_chans_low_log_c$mean_E
all_chans_low_c[11:20] <- M_chans_low_log_c$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_low_c <- as.data.frame(cbind(all_chans_low_c, group))
df_means_low_c$group <- as.factor(df_means_low_c$group)
```
  
**Descriptive statistics, Wilcoxon test and plot:**  
  
- Pirate Plot, the box indicates the IQR and median 
- Median for EasyCap 
- Median for Mobita 
- Wilcoxon test result 
- Fligner-Killeen test 
   
  
```{r low freq results processed, eval=TRUE, echo=FALSE, message=FALSE}  
range_low_median_e <- median(E_chans_low_log_c$mean_E)
range_low_iqr_e <- IQR(E_chans_low_log_c$mean_E)

range_low_median_m <- median(M_chans_low_log_c$mean_M)
range_low_iqr_m <- IQR(M_chans_low_log_c$mean_M)

#Test of mean difference 
range_low_wil <- wilcox.test(E_chans_low_log_c$mean_E, M_chans_low_log_c$mean_M,paired=TRUE)

range_low_es <- wilcox_effsize(df_means_low_c, all_chans_low_c ~ group, paired=TRUE)

#Test of homogeneity of variance 
range_low_flig <- fligner.test(all_chans_low_c ~ group, data = df_means_low_c)

pirateplot(formula = all_chans_low_c~group, #which variables are you using
           data = df_means_low_c,
           theme = 0, 
           main = "0.1 - 2 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(3, 9, by = 1)) #set the numbers on the y axis

```
    
    
There are no significant results in the data.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r range_low_median_e`(`r range_low_iqr_e`)  
**Median for Mobita:** `r range_low_median_m`(`r range_low_iqr_m`)  
  
**Wilcoxon:** V = `r range_low_wil$statistic`, p = `r range_low_wil$p.value`, Bonferroni p = `r range_low_wil$p.value*8`, r = `r range_low_es$effsize` (`r range_low_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r range_low_flig$statistic`, p = `r range_low_flig$p.value`, Bonferroni p = `r range_low_flig$p.value*8`  
  
******  
  
  
## **49-51Hz**    
  

```{r high freq processed, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_range_high <- read.csv("range_50Hz_all.csv")

#remove participant info
df_range_high <- df_range_high[,-c(1,2)]

# Select EasyCap data and log transform
E_chans_high_c <- as.data.frame(df_range_high[1:28])
E_chans_high_log_c <- as.data.frame(lapply(E_chans_high_c, log))
E_chans_high_log_c$mean_E <- rowMeans(E_chans_high_log_c)

# Select Mobita data and log transform
M_chans_high_c <- as.data.frame(df_range_high[29:56])
M_chans_high_log_c <- as.data.frame(lapply(M_chans_high_c, log))
M_chans_high_log_c$mean_M <- rowMeans(M_chans_high_log_c)

# Put the means of both systems in one data frame to be used for plots
all_chans_high_c <- E_chans_high_log_c$mean_E
all_chans_high_c[11:20] <- M_chans_high_log_c$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_high_c <- as.data.frame(cbind(all_chans_high_c, group))
df_means_high_c$group <- as.factor(df_means_high_c$group)

```
  
**Descriptive statistics, Wilcoxon test and plot:**  
  
- Piate Plot with IQR and median 
- Median for EasyCap 
- Median for Mobita 
- Wilcoxon test result 
- Fligner-Killeen test 

```{r high freq results processed, eval=TRUE, echo=FALSE, message=FALSE}
range_high_median_e <- median(E_chans_high_log_c$mean_E)
range_high_iqr_e <- IQR(E_chans_high_log_c$mean_E)

range_high_median_m <- median(M_chans_high_log_c$mean_M)
range_high_iqr_m <- IQR(M_chans_high_log_c$mean_M)

# Test of mean differences
range_high_wil <- wilcox.test(E_chans_high_log_c$mean_E, M_chans_high_log_c$mean_M,paired=TRUE)

range_high_es <- wilcox_effsize(df_means_high_c, all_chans_high_c ~ group, paired=TRUE)


#Test of homogeneity of variances
range_high_flig <- fligner.test(all_chans_high_c ~ group, data = df_means_high_c)

pirateplot(formula = all_chans_high_c~group, #which variables are you using
           data = df_means_high_c,
           theme = 0, 
           main = "49 - 51 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-7, -3, by = 1)) #set the numbers on the y axis


```

There are no significant results in the data.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r range_high_median_e`(`r range_high_iqr_e`)  
**Median for Mobita:** `r range_high_median_m`(`r range_high_iqr_m`)  
  
**Wilcoxon:** V = `r range_high_wil$statistic`, p = `r range_high_wil$p.value`, Bonferroni p = `r range_high_wil$p.value*8`, r = `r range_high_es$effsize` (`r range_high_es$magnitude`)   
  
**Fligner-Killeen:** X^2^ = `r range_high_flig$statistic`, p = `r range_high_flig$p.value`, Bonferroni p = `r range_high_flig$p.value*8`  
  
******  
  

**Raw Freq Plot Log-Transformed 0-60Hz**  
  
![Range_Freq](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\fig2_range_freq.jpg)  

  
******
  
## **Rejected artefactual trials**  
There were three types of trials extracted for the analyses in this study. Stimulus locked trials, response locked trials with correct responses and response locked trials with incorrect responses. Proportion of rejected trials was calculated only for the stimulus-locked trials as the total number of trials was the largest in this type whereas for the response-locked trials, the total number was divided into two types.  
  
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Fligner-Killeen test 

  
```{r artefacts calculations, eval=TRUE, echo=FALSE,  warning=FALSE}

# Calculate the total trials for stimulus-locked trials for EasyCap
df_preproc <- mutate(df_preproc, E_Stim_Total = E_AllEp + E_Rej_AllEp)
#Calculate the proportion of rejected trials
df_preproc <- mutate(df_preproc, E_Stim_Rej_p = (E_Rej_AllEp/E_Stim_Total)*100)

# Calculate the total trials for stimulus-locked trials for Mobita
df_preproc <- mutate(df_preproc, M_Stim_Total = M_AllEp + M_Rej_AllEp)
#Calculate the proportion of rejected trials
df_preproc <- mutate(df_preproc, M_Stim_Rej_p = (M_Rej_AllEp/M_Stim_Total)*100)
  
#EasyCap Median
stim_rej_median_e <- median(df_preproc$E_Stim_Rej_p)
stim_rej_iqr_e <- IQR(df_preproc$E_Stim_Rej_p)
#Mobita Median
stim_rej_median_m <- median (df_preproc$M_Stim_Rej_p)
stim_rej_iqr_m <- IQR(df_preproc$M_Stim_Rej_p)

#Wilcoxon test
stim_rej_wil <- wilcox.test(df_preproc$E_Stim_Rej_p, df_preproc$M_Stim_Rej_p,paired=TRUE)  


# Put the rejection rates of both systems in one data frame to be used for plots
rej_art <- df_preproc$E_Stim_Rej_p
rej_art[11:20] <- df_preproc$M_Stim_Rej_p 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_rej_art <- as.data.frame(cbind(rej_art, group))
df_rej_art$group <- as.factor(df_rej_art$group)

#Flinger test
stim_rej_flig <- fligner.test(rej_art ~ group, data = df_rej_art)

#Calculate the effect size for Wilcoxon
stim_rej_es <- wilcox_effsize(df_rej_art, rej_art ~ group, paired=TRUE)

#plot
pirateplot(formula = rej_art~group, #which variables are you using
           data = df_rej_art,
           theme = 0, 
           main = "Artefact Rejection", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Proportion of Rejected Stimulus-Locked Trials", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(0, 28, by = 4)) #set the numbers on the y axis


``` 
  
Both, the Wilcoxon and the Fligner-Killeen test are significant.  
Bonferroni correction x2 as there are 2 tests looking at artefact rejection in the dataset.    
  
**Median for EasyCap:** `r stim_rej_median_e`(`r stim_rej_iqr_e`)  
**Median for Mobita:** `r stim_rej_median_m`(`r stim_rej_iqr_m`)  
  
**Wilcoxon:** V = `r stim_rej_wil$statistic`, p = `r stim_rej_wil$p.value`, Bonferroni p = `r stim_rej_wil$p.value*2`, r = `r stim_rej_es$effsize` (`r stim_rej_es$magnitude`)
  
**Fligner-Killeen:** X^2^ = `r stim_rej_flig$statistic`, p = `r stim_rej_flig$p.value`, Bonferroni p = `r stim_rej_flig$p.value*2`  
  
******  
  
  
      
## **Signal to Noise Ratio (SNR)**  
The SNR was also extracted from stimulus-locked trials. A subset of electrodes was chosen which excluded electrodes on the edges of the caps which are generally more prone to noise. The final electrode subset included:  F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4.  
  
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Fligner-Killeen test 
  
  

```{r SNR, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}
# Prepare the data frames for selecting the electrodes of interest

# EasyCap
# Transopse
df_SNR_E <- read.csv('SNR_E.csv')
df_SNR_E <- as.data.frame(t(df_SNR_E))
#Column names
colnames(df_SNR_E) <- c('Fp1_E', 'Fp2_E', 'F7_E', 'F3_E', 'Fz_E', 'F4_E', 'F8_E', 'FC5_E', 'FC1_E', 'FC2_E', 'FC6_E', 'T7_E', 'C3_E', 'Cz_E', 'C4_E', 'T8_E', 'CP5_E', 'CP1_E', 'CP2_E', 'CP6_E', 'P7_E', 'P3_E', 'Pz_E', 'P4_E', 'P8_E', 'O1_E', 'O2_E')
df_SNR_E <- df_SNR_E[-1,]
#Select electrodes
df_SNR_E_sub <- select(df_SNR_E, contains(c('F3', 'Fz', 'F4', 'FC5', 'FC1', 'FC2', 'FC6', 'C3', 'Cz', 'C4', 'CP5', 'CP1', 'CP2', 'CP6', 'P3', 'Pz', 'P4')))
# Calculate row means
df_SNR_E_sub <- as.data.frame(lapply(df_SNR_E_sub, as.numeric))
df_SNR_E_sub$SNR_mean_E <- rowMeans(df_SNR_E_sub)
#Add a counting column
df_SNR_E_sub$ncount <- 1:nrow(df_SNR_E_sub)
  

# Mobita
# Transpose
df_SNR_M <- read.csv('SNR_M.csv')
df_SNR_M <- as.data.frame(t(df_SNR_M))
# Column Names
colnames(df_SNR_M) <- c('Fp1_M', 'Fp2_M', 'F7_M', 'F3_M', 'Fz_M', 'F4_M', 'F8_M', 'FC5_M', 'FC1_M', 'FC2_M', 'FC6_M', 'T7_M', 'C3_M', 'Cz_M', 'C4_M', 'T8_M', 'CP5_M', 'CP1_M', 'CP2_M', 'CP6_M', 'P7_M', 'P3_M', 'Pz_M', 'P4_M', 'P8_M', 'O1_M', 'O2_M')
df_SNR_M <- df_SNR_M[-1,] 
#Select electrodes
df_SNR_M_sub <- select(df_SNR_M, contains(c('F3', 'Fz', 'F4', 'FC5', 'FC1', 'FC2', 'FC6', 'C3', 'Cz', 'C4', 'CP5', 'CP1', 'CP2', 'CP6', 'P3', 'Pz', 'P4')))
# Calculate row means
df_SNR_M_sub <- as.data.frame(lapply(df_SNR_M_sub, as.numeric))
df_SNR_M_sub$SNR_mean_M <- rowMeans(df_SNR_M_sub)
#Add a counting column
df_SNR_M_sub$ncount <- 1:nrow(df_SNR_M_sub)


# merge the two data frames
df_SNR_final <- merge(df_SNR_E_sub,df_SNR_M_sub,by="ncount")


#Median EasyCap
SNR_median_e <- median(df_SNR_final$SNR_mean_E)
SNR_iqr_e <- IQR(df_SNR_final$SNR_mean_E)
#Median Mobita
SNR_median_m <- median(df_SNR_final$SNR_mean_M)
SNR_iqr_m <- IQR(df_SNR_final$SNR_mean_M)

#Wilcoxon test
SNR_wil <- wilcox.test(df_SNR_final$SNR_mean_E, df_SNR_final$SNR_mean_M,paired=TRUE)

#Prepare the data to plot
SNR <- df_SNR_final$SNR_mean_E
SNR[11:20] <- df_SNR_final$SNR_mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_SNR_plot <- as.data.frame(cbind(SNR, group))
df_SNR_plot$group <- as.factor(df_SNR_plot$group) 

#calculate the effect size from the data frame prepared for plotting
SNR_es <- wilcox_effsize(df_SNR_plot, SNR ~ group, paired=TRUE)
  
#calculate the test of variance
SNR_flig <- fligner.test(SNR ~ group, data = df_SNR_plot)

#Plot
pirateplot(formula = SNR~group, #which variables are you using
           data = df_SNR_plot,
           theme = 0, 
           main = "Signal to Noise Ratio per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Signal to Noise Ratio", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(0.01, .18, by = 0.03)) #set the numbers on the y axis

```

The results are non-significant.  
Bonferroni correction x4 as there are 2 tests and 2 measures of noise.  
  
**Median for EasyCap:** `r SNR_median_e`(`r SNR_iqr_e`)  
**Median for Mobita:** `r SNR_median_m`(`r SNR_median_m`)  
  
**Wilcoxon:** V = `r SNR_wil$statistic`, p = `r SNR_wil$p.value`, Bonferroni p = `r SNR_wil$p.value*4`, r = `r SNR_es$effsize` (`r SNR_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r SNR_flig$statistic`, p = `r SNR_flig$p.value`, Bonferroni p = `r SNR_flig$p.value*4`  
  
  
  
  
## **Root-Mean Square (RMS)**  
The RMS values were also extracted from stimulus-locked trials. A subset of electrodes was chosen which excluded electrodes on the edges of the caps which are generally more prone to noise. The final electrode subset included:  F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4.  
  
-  Pirate Plot 
-  Median (IQR) for Easy Cap 
-  Median (IQR) for Mobita 
-  Wilcoxon test results 
-  Flinger-Killeen test 
  
  
```{r RMS, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}

df_RMS <- read.csv('RMS.csv')  
  
#Median EasyCap
RMS_median_e <- median(df_RMS$RMS_E_subset)
RMS_iqr_e <- IQR(df_RMS$RMS_E_subset)
#Median Mobita
RMS_median_m <- median(df_RMS$RMS_M_subset)
RMS_iqr_m <- IQR(df_RMS$RMS_M_subset)

#Wilcoxon test
RMS_wil <- wilcox.test(df_RMS$RMS_E_subset, df_RMS$RMS_M_subset,paired=TRUE)  

#prepare the data for plotting 
RMS <- df_RMS$RMS_E_subset
RMS[11:20] <- df_RMS$RMS_M_subset 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_RMS_plot <- as.data.frame(cbind(RMS, group))
df_RMS_plot$group <- as.factor(df_RMS_plot$group)  

#run the fligner test of variance using the new data frame
RMS_flig <- fligner.test(RMS ~ group, data = df_RMS_plot)

#calculate the Wilcoxon effect size using the new data frame
RMS_es <- wilcox_effsize(df_RMS_plot, RMS ~ group, paired=TRUE)

#plot the data 
pirateplot(formula = RMS~group, #which variables are you using
           data = df_RMS_plot,
           theme = 0, 
           main = "Root Mean Squared per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Signal to Noise Ratio in micro volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(7, 98, by = 10)) #set the numbers on the y axis

```

Fligner-Kileen test is significant for RMS between EasyCap and Mobita.  
Bonferroni correction x4 as there are 2 tests and 2 measures of noise.  
  
**Median for EasyCap:** `r RMS_median_e`(`r RMS_iqr_e`)  
**Median for Mobita:** `r RMS_median_m`(`r RMS_iqr_m`)  
  
**Wilcoxon:** V = `r RMS_wil$statistic`, p = `r RMS_wil$p.value`, Bonferroni p = `r RMS_wil$p.value*4`,  r = `r RMS_es$effsize` (`r RMS_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r RMS_flig$statistic`, p = `r RMS_flig$p.value`, Bonferroni p = `r RMS_flig$p.value*4`  
  


# 
# Comparison of frequency activity between the two systems  
  
******

## **Theta analysis**
```{r load data, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_theta <- read.csv("FFT_range_theta_all.csv")

```

**1. Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems.   
Select from a subset of frontal elecrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: Fz, F4, FC1, FC2  

```{r matched electrodes, eval=TRUE, echo=FALSE}

df_theta_matched <- df_theta
df_theta_matched <- select(df_theta_matched, starts_with(c("Fz", "F4", "FC1", "FC2")))

```


```{r theta average, eval=TRUE, echo=FALSE}

df_theta_matched <- as.data.frame(apply(df_theta_matched, 2, as.numeric))

# EasyCap

theta_E <- df_theta_matched
theta_E <- select(df_theta_matched, contains("E")) 
                   
# add the averages to the dataframe
df_theta_matched$theta_av_E <- rowMeans(theta_E)

# log transform the data for ease of visual interpretation
df_theta_matched$theta_av_E_log <- log(df_theta_matched$theta_av_E)


# Mobita
theta_M <- df_theta_matched
theta_M <- select(df_theta_matched, contains("M")) 
                   
# add the averages to the dataframe
df_theta_matched$theta_av_M <- rowMeans(theta_M)

# log transform the data for ease of visual interpretation
df_theta_matched$theta_av_M_log <- log(df_theta_matched$theta_av_M)

```


**2. Results **   
  
- Spearman Correlation 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Correlation Plot 
- Wilcoxon Test 
- Fligner-Killeen test  
  


```{r theta plot and test, eval=TRUE, echo=FALSE, message=FALSE}

theta_median_e <- median(df_theta_matched$theta_av_E_log)
theta_iqr_e <- IQR(df_theta_matched$theta_av_E_log)

theta_median_m <- median(df_theta_matched$theta_av_M_log)
theta_iqr_m <- IQR(df_theta_matched$theta_av_M_log)

theta_cor <- cor.test(df_theta_matched$theta_av_E_log, df_theta_matched$theta_av_M_log, method="kendall") 


ggplot(df_theta_matched, aes(x=theta_av_E_log, y=theta_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

theta_wil <- wilcox.test(df_theta_matched$theta_av_E_log, df_theta_matched$theta_av_M_log, paired=TRUE)  

all_theta_av <- df_theta_matched$theta_av_E_log
all_theta_av[11:20] <- df_theta_matched$theta_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_theta_av <- as.data.frame(cbind(all_theta_av, group))
df_theta_av$group <- as.factor(df_theta_av$group)  
  
#test of variance 
theta_flig <- fligner.test(all_theta_av ~ group, data = df_theta_av)

#wilcoxon effect size using the new data structure
theta_es <- wilcox_effsize(df_theta_av, all_theta_av ~ group, paired=TRUE)


pirateplot(formula = all_theta_av~group, #which variables are you using
           data = df_theta_av,
           theme = 0, 
           main = "Theta Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Theta Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-2, 3, by = 1)) #set the numbers on the y axis

```
  
  
There are no statistically significant results in the data.    
Bonferroni correction x12 as there are 4 frequency bands and 3 tests each.    
    
**Median EasyCap =** `r theta_median_e`(`r theta_iqr_e`)  
  
**Median Mobita =** `r theta_median_m`(`r theta_iqr_m`)  
  
**Correlation:** r = `r theta_cor$estimate`, p = `r theta_cor$p.value`, Bonferroni p = `r theta_cor$p.value*12`  
  
**Wilcoxon:** V = `r theta_wil$statistic`, p = `r theta_wil$p.value`, Bonferroni p = `r theta_wil$p.value*12`, r = `r theta_es$effsize` (`r theta_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r theta_flig$statistic`, p = `r theta_flig$p.value`, Bonferroni p = `r theta_flig$p.value*12`  
   
******
  
## **Alpha analysis** 
```{r load data alpha, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_alpha <- read.csv("FFT_range_alpha_all.csv")

```

**Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems.   
Select from a subset of frontal elecrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: Fz, Pz, P4  
  

```{r matched electrodes alpha, eval=TRUE, echo=FALSE}

df_alpha_matched <- df_alpha
df_alpha_matched <- select(df_alpha, starts_with(c("Fz", "Pz", "P4")))


```


```{r alpha average, eval=TRUE, echo=FALSE}

df_alpha_matched <- as.data.frame(apply(df_alpha_matched, 2, as.numeric))

# EasyCap

alpha_E <- df_alpha_matched
alpha_E <- select(df_alpha_matched, contains("E")) 
                   
# add the averages to the dataframe
df_alpha_matched$alpha_av_E <- rowMeans(alpha_E)

# log transform the data for ease of visual interpretation
df_alpha_matched$alpha_av_E_log <- log(df_alpha_matched$alpha_av_E)


# Mobita

alpha_M <- df_alpha_matched
alpha_M <- select(df_alpha_matched, contains("M")) 
                   
# add the averages to the dataframe
df_alpha_matched$alpha_av_M <- rowMeans(alpha_M)

# log transform the data for ease of visual interpretation
df_alpha_matched$alpha_av_M_log <- log(df_alpha_matched$alpha_av_M)

```


**2. Results **   
  
- Correlation Plot 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Spearman Correlation 
- Wilcoxon Test 
- Fligner-Killeen test  
  
  
  
```{r alpha plot and test, eval=TRUE, echo=FALSE, message=FALSE}

alpha_median_e <- median(df_alpha_matched$alpha_av_E_log)
alpha_iqr_e <- IQR(df_alpha_matched$alpha_av_E_log)

alpha_median_m <- median(df_alpha_matched$alpha_av_M_log)
alpha_iqr_m <- IQR(df_alpha_matched$alpha_av_M_log)

alpha_cor <- cor.test(df_alpha_matched$alpha_av_E_log, df_alpha_matched$alpha_av_M_log, method="kendall")


ggplot(df_alpha_matched, aes(x=alpha_av_E_log, y=alpha_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

alpha_wil <- wilcox.test(df_alpha_matched$alpha_av_E_log, df_alpha_matched$alpha_av_M_log, paired=TRUE)  
  
all_alpha_av <- df_alpha_matched$alpha_av_E_log
all_alpha_av[11:20] <- df_alpha_matched$alpha_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_alpha_av <- as.data.frame(cbind(all_alpha_av, group))
df_alpha_av$group <- as.factor(df_alpha_av$group)  

#use the new data structure for the variance test
alpha_flig <- fligner.test(all_alpha_av ~ group, data = df_alpha_av)

#wilcoxon effect size using the new data structure
alpha_es <- wilcox_effsize(df_alpha_av, all_alpha_av ~ group, paired=TRUE)

pirateplot(formula = all_alpha_av~group, #which variables are you using
           data = df_alpha_av,
           theme = 0, 
           main = "Alpha Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Alpha Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-3, 1, by = 0.5)) #set the numbers on the y axis

```
  
There are no statistically significant results in the data.  
Bonferroni correction x12 as there are 4 frequency bands and 3 tests each.  
  
**Median EasyCap =** `r alpha_median_e`(`r alpha_iqr_e`)     
  
**Median Mobita =** `r alpha_median_m`(`r alpha_iqr_m`) 

**Correlation:** r = `r alpha_cor$estimate`, p = `r alpha_cor$p.value`, Bonferroni p = `r alpha_cor$p.value*12`  
  
**Wilcoxon:** V = `r alpha_wil$statistic`, p = `r alpha_wil$p.value`, Bonferroni p = `r alpha_wil$p.value*12`, r = `r alpha_es$effsize` (`r alpha_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r alpha_flig$statistic`, p = `r alpha_flig$p.value`, Bonferroni p = `r alpha_flig$p.value*12`  
  
  
******  

## **Low Beta Analysis**
```{r load data lbeta, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_lbeta <- read.csv("FFT_range_low_beta_all.csv")

```

**1. Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems.   
Select from a subset of frontal elecrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: F4  

```{r matched electrodes lbeta, eval=TRUE, echo=FALSE}

df_lbeta_matched <- df_lbeta
df_lbeta_matched <- select(df_lbeta, starts_with("F4"))

```


```{r lbeta average, eval=TRUE, echo=FALSE}

df_lbeta_matched <- as.data.frame(apply(df_lbeta_matched, 2, as.numeric))

# EasyCap

lbeta_E <- df_lbeta_matched
lbeta_E <- select(df_lbeta_matched, contains("E")) 
                   
# add the averages to the dataframe
df_lbeta_matched$lbeta_av_E <- rowMeans(lbeta_E)

# log transform the data for ease of visual interpretation
df_lbeta_matched$lbeta_av_E_log <- log(df_lbeta_matched$lbeta_av_E)


# Mobita

lbeta_M <- df_lbeta_matched
lbeta_M <- select(df_lbeta_matched, contains("M")) 
                   
# add the averages to the dataframe
df_lbeta_matched$lbeta_av_M <- rowMeans(lbeta_M)

# log transform the data for ease of visual interpretation
df_lbeta_matched$lbeta_av_M_log <- log(df_lbeta_matched$lbeta_av_M)

```


**2. Results **   
  
- Correlation Plot 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Spearman Correlation 
- Wilcoxcon Test 
- Fligner-Killeen test  
  
  

```{r lbeta plot and test, eval=TRUE, echo=FALSE, message=FALSE}

lbeta_median_e <- median(df_lbeta_matched$lbeta_av_E_log)
lbeta_iqr_e <- IQR(df_lbeta_matched$lbeta_av_E_log)

lbeta_median_m <- median(df_lbeta_matched$lbeta_av_M_log)
lbeta_iqr_m <- IQR(df_lbeta_matched$lbeta_av_M_log)

lbeta_cor <- cor.test(df_lbeta_matched$lbeta_av_E_log, df_lbeta_matched$lbeta_av_M_log, method="kendall")


ggplot(df_lbeta_matched, aes(x=lbeta_av_E_log, y=lbeta_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

lbeta_wil <- wilcox.test(df_lbeta_matched$lbeta_av_E_log, df_lbeta_matched$lbeta_av_M_log, paired=TRUE)


all_lbeta_av <- df_lbeta_matched$lbeta_av_E_log
all_lbeta_av[11:20] <- df_lbeta_matched$lbeta_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_lbeta_av <- as.data.frame(cbind(all_lbeta_av, group))
df_lbeta_av$group <- as.factor(df_lbeta_av$group)  

#test of variance using the new data structure
lbeta_flig <- fligner.test(all_lbeta_av ~ group, data = df_lbeta_av)

#wilcoxon effect size using the new data structure
lbeta_es <- wilcox_effsize(df_lbeta_av, all_lbeta_av ~ group, paired=TRUE)

pirateplot(formula = all_lbeta_av~group, #which variables are you using
           data = df_lbeta_av,
           theme = 0, 
           main = "Low Beta Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Low Beta Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-4.5, 0, by = 0.5)) #set the numbers on the y axis

```

There are no statistically significant results in the data.  
Bonferroni correction x12 as there are 4 frequency bands and 3 tests each.  
  
**Median EasyCap =** `r lbeta_median_e`(`r lbeta_iqr_e`)  
  
**Median Mobita =** `r lbeta_median_m`(`r lbeta_iqr_m`)  

**Correlation:** r = `r lbeta_cor$estimate`, p = `r lbeta_cor$p.value`, Bonferroni p = `r lbeta_cor$p.value*12`  
  
**Wilcoxon:** V = `r lbeta_wil$statistic`, p = `r lbeta_wil$p.value`, Bonferroni p = `r lbeta_wil$p.value*12`, r = `r lbeta_es$effsize` (`r lbeta_es$magnitude`)   
  
**Fligner-Killeen:** X^2^ = `r lbeta_flig$statistic`, p = `r lbeta_flig$p.value`, Bonferroni p = `r lbeta_flig$p.value*12`
  
******    
  
  
## **High Beta Analysis**
```{r load data hbeta, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_hbeta <- read.csv("FFT_range_high_beta_all.csv")

```

**Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems.   
Select from a subset of frontal elecrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: CP1, CP2, Pz, P4   

```{r matched electrodes hbeta, eval=TRUE, echo=FALSE}

df_hbeta_matched <- df_hbeta
df_hbeta_matched <- select(df_hbeta, starts_with(c("CP1", "CP2", "Pz", "P4")))

```


```{r hbeta average, eval=TRUE, echo=FALSE}

df_hbeta_matched <- as.data.frame(apply(df_hbeta_matched, 2, as.numeric))

# EasyCap

hbeta_E <- df_hbeta_matched
hbeta_E <- select(df_hbeta_matched, contains("E")) 
                   
# add the averages to the dataframe
df_hbeta_matched$hbeta_av_E <- rowMeans(hbeta_E)

# log transform the data for ease of visual interpretation
df_hbeta_matched$hbeta_av_E_log <- log(df_hbeta_matched$hbeta_av_E)


# Mobita

hbeta_M <- df_hbeta_matched
hbeta_M <- select(df_hbeta_matched, contains("M")) 
                   
# add the averages to the dataframe
df_hbeta_matched$hbeta_av_M <- rowMeans(hbeta_M)

# log transform the data for ease of visual interpretation
df_hbeta_matched$hbeta_av_M_log <- log(df_hbeta_matched$hbeta_av_M)

```


**2. Results **   
  
- Correlation Plot 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Spearman Correlation 
- Wilcoxon Test 
- Fligner-Killeen test  
  

```{r hbeta plot and test, eval=TRUE, echo=FALSE, message=FALSE}

hbeta_median_e <- median(df_hbeta_matched$hbeta_av_E_log)
hbeta_iqr_e <- IQR(df_hbeta_matched$hbeta_av_E_log)

hbeta_median_m <- median(df_hbeta_matched$hbeta_av_M_log)
hbeta_iqr_m <- IQR(df_hbeta_matched$hbeta_av_M_log)

hbeta_cor <- cor.test(df_hbeta_matched$hbeta_av_E_log, df_hbeta_matched$hbeta_av_M_log, method="kendall")


ggplot(df_hbeta_matched, aes(x=hbeta_av_E_log, y=hbeta_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

hbeta_wil <- wilcox.test(df_hbeta_matched$hbeta_av_E_log, df_hbeta_matched$hbeta_av_M_log, paired=TRUE)  

all_hbeta_av <- df_hbeta_matched$hbeta_av_E_log
all_hbeta_av[11:20] <- df_hbeta_matched$hbeta_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_hbeta_av <- as.data.frame(cbind(all_hbeta_av, group))
df_hbeta_av$group <- as.factor(df_hbeta_av$group)  

#use the new data structure for the test of variance
hbeta_flig <- fligner.test(all_hbeta_av ~ group, data = df_hbeta_av)

#wilcoxon effect size using the new data structure
hbeta_es <- wilcox_effsize(df_hbeta_av, all_hbeta_av ~ group, paired=TRUE)

pirateplot(formula = all_hbeta_av~group, #which variables are you using
           data = df_hbeta_av,
           theme = 0, 
           main = "High Beta Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="High Beta Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-5, -1.5, by = 0.5)) #set the numbers on the y axis

```
  
There are no statistically significant results in the data.  
Bonferroni correction x12 as there are 4 frequency bands and 3 tests each.  
  
**Median EasyCap =** `r hbeta_median_e`(`r hbeta_iqr_e`)  
  
**Median Mobita =** `r hbeta_median_m`(`r hbeta_iqr_m`)  

**Correlation:** r = `r hbeta_cor$estimate`, p = `r hbeta_cor$p.value`, Bonferroni p = `r hbeta_cor$p.value*12`  
  
**Wilcoxon:** V = `r hbeta_wil$statistic`, p = `r hbeta_wil$p.value`, Bonferroni p = `r hbeta_wil$p.value*12`, r = `r hbeta_es$effsize` (`r hbeta_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r hbeta_flig$statistic`, p = `r hbeta_flig$p.value`, Bonferroni p = `r hbeta_flig$p.value*12`
  
******  



## **Frequency Topographies**  

![Plots](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\freq_topographies.jpg)


# 
# Comparison of Event-Related Potentials between the two systems 

## **P300**  
**Mean Amplitude**
  
- Correlation Plot 
- Pirate Plot 
- Median for Easy Cap 
- Median for Mobita 
- Correlation Test 
- Wilcoxon test results 
- Fligner-Killeen test  
  
  
```{r P300, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}

df_P300 <- read.csv('P300.csv')

#Median EasyCap
P300_median_e <- median(df_P300$Pz_E)
#Median Mobita
P300_median_m <- median(df_P300$Pz_M)

#Spearman Correlation
P300_cor <- cor.test(df_P300$Pz_E, df_P300$Pz_M, method="spearman")

#Correlation plot
ggplot(df_P300, aes(x=Pz_E, y=Pz_M))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()


#Wilcoxon test
P300_wil <- wilcox.test(df_P300$Pz_E, df_P300$Pz_M, paired=TRUE)  

P300 <- df_P300$Pz_E
P300[11:20] <- df_P300$Pz_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_P300_plot <- as.data.frame(cbind(P300, group))
df_P300_plot$group <- as.factor(df_P300_plot$group)

P300_flig <- fligner.test(P300 ~ group, data = df_P300_plot)

pirateplot(formula = P300~group, #which variables are you using
           data = df_P300_plot,
           theme = 0, 
           main = "P300 Mean Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="P300 Mean Amplitude in Micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-1, 5, by = 1)) #set the numbers on the y axis

```
The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r P300_median_e`     
  
**Median Mobita =** `r P300_median_m`  

**Correlation:** r = `r P300_cor$estimate`, p = `r P300_cor$p.value`, Bonferroni p = `r P300_cor$p.value*14`  
  
**Wilcoxon:** V = `r P300_wil$statistic`, p = `r P300_wil$p.value`, Bonferroni p = `r P300_wil$p.value*14`  
  
**Fligner-Killeen:** X^2^ = `r P300_flig$statistic`, p = `r P300_flig$p.value`, Bonferroni p = `r P300_flig$p.value*14`
  
******  
 

  
**Latency**  

- Pirate Plot 
- Median for Easy Cap 
- Median for Mobita 
- Wilcoxon test results 
- Fligner-Killeen test  
  

```{r P300 latency, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}
#the peaks a re extracted from the difference wave already
df_P300_peak <- read.csv('P300_peak.csv')


#Median for the peak latency EasyCap
P300_lat_median_e <- median(df_P300_peak$Time_E)
#Median for the peak latency Mobita
P300_lat_median_m <- median(df_P300_peak$Time_M)

#Wilcoxon test
P300_lat_wil <- wilcox.test(df_P300_peak$Time_E, df_P300_peak$Time_M, paired=TRUE)  

P300_peak <- df_P300_peak$Time_E
P300_peak[11:20] <- df_P300_peak$Time_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_P300_peak_plot <- as.data.frame(cbind(P300_peak, group))
df_P300_peak_plot$group <- as.factor(df_P300_peak_plot$group)

P300_lat_flig <- fligner.test(P300_peak ~ group, data = df_P300_peak_plot)

pirateplot(formula = P300_peak~group, #which variables are you using
           data = df_P300_peak_plot,
           theme = 0, 
           main = "P300 Peak Latency Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="P300 Peak Time in ms", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(266, 379, by = 10)) #set the numbers on the y axis

```  
  
The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r P300_lat_median_e`     
  
**Median Mobita =** `r P300_lat_median_m`  

**Wilcoxon:** V = `r P300_lat_wil$statistic`, p = `r P300_lat_wil$p.value`, Bonferroni p = `r P300_lat_wil$p.value*14`  
  
**Fligner-Killeen:** X^2^ = `r P300_lat_flig$statistic`, p = `r P300_lat_flig$p.value`, Bonferroni p = `r P300_lat_flig$p.value*14`
  
******  
  
  
  
**Amplitude**  
  

- Pirate Plot 
- Median for Easy Cap 
- Median for Mobita 
- Wilcoxon test results 
- Fligner-Killeen test  
  
  
```{r P300 amplitude, eval=TRUE, echo=FALSE,  warning=FALSE}
#the peaks a re extracted from the difference wave already
df_P300_peak <- read.csv('P300_peak.csv')


#Median for the peak latency EasyCap
P300_amp_median_e <- median(df_P300_peak$Amp_E)
#Median for the peak latency Mobita
P300_amp_median_m <- median(df_P300_peak$Amp_M)

#Wilcoxon test
P300_amp_wil <- wilcox.test(df_P300_peak$Amp_E, df_P300_peak$Amp_M, paired=TRUE)  

P300_peak_amp <- df_P300_peak$Amp_E
P300_peak_amp[11:20] <- df_P300_peak$Amp_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_P300_peak_amp_plot <- as.data.frame(cbind(P300_peak_amp, group))
df_P300_peak_amp_plot$group <- as.factor(df_P300_peak_amp_plot$group)

P300_amp_flig <- fligner.test(P300_peak_amp ~ group, data = df_P300_peak_amp_plot)

pirateplot(formula = P300_peak_amp~group, #which variables are you using
           data = df_P300_peak_amp_plot,
           theme = 0, 
           main = "P300 Peak Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="P300 Peak Amplitude in micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-3, 8, by = 3)) #set the numbers on the y axis

```  
 
The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r P300_amp_median_e`     
  
**Median Mobita =** `r P300_amp_median_m`  

**Wilcoxon:** V = `r P300_amp_wil$statistic`, p = `r P300_amp_wil$p.value`, Bonferroni p = `r P300_amp_wil$p.value*14`  
  
**Fligner-Killeen:** X^2^ = `r P300_amp_flig$statistic`, p = `r P300_amp_flig$p.value`, Bonferroni p = `r P300_amp_flig$p.value*14`
  
******  
  

**P300 Plots**  
![Plots](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\P300.jpg)  
  
## **Investigating why the P300 is shifed frontally**    
  
**EasyCap and Mobita P300 activity at Fz and Pz**  
EasyCap is in black and Mobita is in red.  

![P300 waves](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\P300_fz_pz.jpg)  
  
Here the activity looks stronger for Fz in Mobita in comparison to Fz in EasyCap and in comparison to Mobita activity at Pz.  
  
I have checked referencing and it seems that the references are the same. The only difference is that in EasyCap, the mastoid electrodes that were implicitly recorded are included in the mean whereas in Mobita I did not include the masoid electodes for the mean calculation (as I thought they would not be included in EasyCap).  
  
**SNR distribution across different areas of electrodes**  
#The electrodes will be divided into 3 areas and the mean SNR values for those areas will be compared using the Wilcoxon and Fligner-Killeen tests.  
  
Frontal: Fp1, F2p, F7, F3, Fz, F4, F8,   
Central: FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6  
Posterior: P7, P3, Pz, P4, P8, O1, O2 
  
```{r SNR distribution, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}

#Make a new data frame where SNR data from EasyCap and Mobita will be combined. The name of the columns has to be the same so rename these first.

df_SNR_all <- df_SNR_E
colnames(df_SNR_all) <- c('Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'FC1', 'FC2', 'FC6', 'T7', 'C3', 'Cz', 'C4', 'T8', 'CP5', 'CP1', 'CP2', 'CP6', 'P7', 'P3', 'Pz', 'P4', 'P8', 'O1', 'O2') 

df_SNR_M_renamed <- df_SNR_M
colnames(df_SNR_M_renamed) <- c('Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'FC1', 'FC2', 'FC6', 'T7', 'C3', 'Cz', 'C4', 'T8', 'CP5', 'CP1', 'CP2', 'CP6', 'P7', 'P3', 'Pz', 'P4', 'P8', 'O1', 'O2')

#Merge EasyCap and Mobita data into one data frame
df_SNR_all <- bind_rows(df_SNR_all, df_SNR_M_renamed)

# Make a new data frame for frontal electrodes and calculate the means
df_SNR_frontal <-  df_SNR_all[,c('Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8')]
df_SNR_frontal <- as.data.frame(lapply(df_SNR_frontal, as.numeric))
df_SNR_frontal$mean_frontal <- rowMeans(df_SNR_frontal)

# Make a new data frame for central electrodes and calculate the means
df_SNR_central <- df_SNR_all[,c('FC5','FC1', 'FC2', 'FC6','C3', 'Cz', 'C4','CP5', 'CP1', 'CP2', 'CP6')]
df_SNR_central <- as.data.frame(lapply(df_SNR_central, as.numeric))
df_SNR_central$mean_central <- rowMeans(df_SNR_central)

# Make a new data frame for posterior electrodes and calculate the means
df_SNR_posterior <- df_SNR_all[,c('P7', 'P3', 'Pz', 'P4', 'P8', 'O1', 'O2')]
df_SNR_posterior <- as.data.frame(lapply(df_SNR_posterior, as.numeric))
df_SNR_posterior$mean_posterior <- rowMeans(df_SNR_posterior)

#Add the means back to the main data frame
df_SNR_all$mean_frontal <- df_SNR_frontal$mean_frontal
df_SNR_all$mean_central <- df_SNR_central$mean_central
df_SNR_all$mean_posterior <- df_SNR_posterior$mean_posterior

#Prepare a new data frame with a layout suitable for plotting
SNR_areas <- 1:20
SNR_areas[1:20] <- df_SNR_frontal$mean_frontal
SNR_areas[21:40] <- df_SNR_central$mean_central
SNR_areas[41:60] <- df_SNR_posterior$mean_posterior

area <- rep("Frontal", 20)
area[21:40] <- rep("Central",20)
area[41:60] <- rep("Posterior",20)  
  
group_SNR <- rep(1, 10)
group_SNR[11:20] <- rep(2, 10)
group_SNR[21:30] <- rep(1, 10)
group_SNR[31:40] <- rep(2, 10)
group_SNR[41:50] <- rep(1, 10)
group_SNR[51:60] <- rep(2, 10)

df_SNR_areas <- as.data.frame(cbind(SNR_areas, area, group_SNR))
df_SNR_areas$SNR_areas <- as.numeric((df_SNR_areas$SNR_areas))

 

pirateplot(formula = SNR_areas ~ area + group_SNR, #which variables are you using
           data = df_SNR_areas,
           theme = 0, 
           main = "SNR per area per system", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="SNR values", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(0.007, 0.190 , by = 0.015)) #set the numbers on the y axis

# Create vectors for the wilcoxon test
SNR_frontal_e <- df_SNR_all$mean_frontal[1:10]
SNR_frontal_m <- df_SNR_all$mean_frontal[11:20]

SNR_central_e <- df_SNR_all$mean_central[1:10]
SNR_central_m <- df_SNR_all$mean_central[11:20]

SNR_posterior_e <- df_SNR_all$mean_posterior[1:10]
SNR_posterior_m <- df_SNR_all$mean_posterior[11:20]

# Run the Wilcoxon tests
SNR_frontal_wil <- wilcox.test(SNR_frontal_e, SNR_frontal_m, paired=TRUE)  
SNR_central_wil <- wilcox.test(SNR_central_e, SNR_central_m, paired=TRUE) 
SNR_posterior_wil <- wilcox.test(SNR_posterior_e, SNR_posterior_m, paired=TRUE)


#Prepare data for the Fligner tests  
df_SNR_frontal$group <- group
df_SNR_central$group <- group
df_SNR_posterior$group <- group
#Run the Fligner-Killeen tests
SNR_frontal_flig <- fligner.test(mean_frontal ~ group, data = df_SNR_frontal)
SNR_central_flig <- fligner.test(mean_central ~ group, data = df_SNR_central)
SNR_posterior_flig <- fligner.test(mean_posterior ~ group, data = df_SNR_posterior)
```

The results from Wilcoxon test are significant for the posterior electrodes. All other tests are non-significant.  
Because there are 4 other tests looking at noise in the data, p-value will be multiplied by 10.  
Bonferroni correction x10.  
  
**Frontal electrodes**  
Wilcoxon: `r SNR_frontal_wil$statistic`, p-value = `r SNR_frontal_wil$p.value`, Bonferroni p-value: `r SNR_frontal_wil$p.value*10`  
Fligner-Killeen: `r SNR_frontal_flig$statistic`, p-value = `r SNR_frontal_flig$p.value`, Bonferroni p-value: `r SNR_frontal_flig$p.value*10`  
  
**Central electrodes**  
Wilcoxon: `r SNR_central_wil$statistic`, p-value = `r SNR_central_wil$p.value`, Bonferroni p-value: `r SNR_central_wil$p.value*10`  
Fligner-Killeen: `r SNR_central_flig$statistic`, p-value = `r SNR_central_flig$p.value`, Bonferroni p-value: `r SNR_central_flig$p.value*10`  

**Posterior electrodes**  
Wilcoxon: `r SNR_posterior_wil$statistic`, p-value = `r SNR_posterior_wil$p.value`, Bonferroni p-value: `r SNR_posterior_wil$p.value*10`  
Fligner-Killeen: `r SNR_posterior_flig$statistic`, p-value = `r SNR_posterior_flig$p.value`, Bonferroni p-value: `r SNR_posterior_flig$p.value*10`  
  
  
  
## **ERN**  
  
**Mean Amplitude** 

- Correlation Plot 
- Pirate Plot 
- Median for Easy Cap 
- Median for Mobita 
- Correlation Test 
- Wilcoxon test results 
  

```{r ERN, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}

df_ERN <- read.csv('ERN.csv')
#remove participant 4 as they only had 5 trials available for comparison
df_ERN <- df_ERN[-4,]

#create difference waves 
# EasyCap
df_ERN <- mutate(df_ERN, dif_E = Err_Cz_E - Corr_Cz_E)
#Mobita
df_ERN <- mutate(df_ERN, dif_M = Err_Cz_M - Corr_Cz_M)

#Median for the difference wave EasyCap
ERN_median_e <- median(df_ERN$dif_E)
#Median for the difference wave Mobita
ERN_median_m <- median(df_ERN$dif_M)

#Spearman Correlation
ERN_cor <- cor.test(df_ERN$dif_E, df_ERN$dif_M, method="spearman")

#Correlation plot
ggplot(df_ERN, aes(x=dif_E, y=dif_M))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()


#Wilcoxon test
ERN_wil <- wilcox.test(df_ERN$dif_E, df_ERN$dif_M, paired=TRUE)  

ERN <- df_ERN$dif_E
ERN[10:18] <- df_ERN$dif_M 
group <- 1:18
group[1:9] <- 1
group[10:18] <- 2
df_ERN_plot <- as.data.frame(cbind(ERN, group))
df_ERN_plot$group <- as.factor(df_ERN_plot$group)

ERN_flig <- fligner.test(ERN ~ group, data = df_ERN_plot)

pirateplot(formula = ERN~group, #which variables are you using
           data = df_ERN_plot,
           theme = 0, 
           main = "ERN Mean Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Mean Amplitude in Micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-1.5, 6.5, by = 1)) #set the numbers on the y axis

```

The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r ERN_median_e`     
  
**Median Mobita =** `r ERN_median_m`  

**Wilcoxon:** V = `r ERN_wil$statistic`, p = `r ERN_wil$p.value`, Bonferroni p = `r ERN_wil$p.value*14`  
  
**Fligner-Killeen:** X^2^ = `r ERN_flig$statistic`, p = `r ERN_flig$p.value`, Bonferroni p = `r ERN_flig$p.value*14`
  
******  
  
  
**Peak Latency**  

- Pirate Plot 
- Median for Easy Cap 
- Median for Mobita 
- Wilcoxon test results 
  

```{r ERN latency, eval=TRUE, echo=FALSE,  warning=FALSE}
#the peaks a re extracted from the difference wave already
df_ERN_peak <- read.csv('ERN_peak.csv')


#Median for the peak latency EasyCap
ERN_lat_median_e <- median(df_ERN_peak$Time_E)
#Median for the peak latency Mobita
ERN_lat_median_m <- median(df_ERN_peak$Time_M)

#Wilcoxon test
ERN_lat_wil <- wilcox.test(df_ERN_peak$Time_E, df_ERN_peak$Time_M, paired=TRUE)  

ERN_peak <- df_ERN_peak$Time_E
ERN_peak[10:18] <- df_ERN_peak$Time_M 
group <- 1:18
group[1:9] <- 1
group[10:18] <- 2
df_ERN_peak_plot <- as.data.frame(cbind(ERN_peak, group))
df_ERN_peak_plot$group <- as.factor(df_ERN_peak_plot$group)

ERN_lat_flig <- fligner.test(ERN_peak ~ group, data = df_ERN_peak_plot)

pirateplot(formula = ERN_peak~group, #which variables are you using
           data = df_ERN_peak_plot,
           theme = 0, 
           main = "ERN Peak Latency Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Peak Time in ms", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-26, 71, by = 10)) #set the numbers on the y axis

```  
  
The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r ERN_lat_median_e`     
  
**Median Mobita =** `r ERN_lat_median_m`  

**Wilcoxon:** V = `r ERN_lat_wil$statistic`, p = `r ERN_lat_wil$p.value`, Bonferroni p = `r ERN_lat_wil$p.value*14`  
  
**Fligner-Killeen:** X^2^ = `r ERN_lat_flig$statistic`, p = `r ERN_lat_flig$p.value`, Bonferroni p = `r ERN_lat_flig$p.value*14`
  
******  


**Peak Amplitude**  
  
- Pirate Plot 
- Median for Easy Cap 
- Median for Mobita 
- Wilcoxon test results 
  
```{r ERN amplitude, eval=TRUE, echo=FALSE,  warning=FALSE}
#the peaks a re extracted from the difference wave already
df_ERN_peak <- read.csv('ERN_peak.csv')


#Median for the peak latency EasyCap
ERN_amp_median_e <- median(df_ERN_peak$Amp_E)
#Median for the peak latency Mobita
ERN_amp_median_m <- median(df_ERN_peak$Amp_M)

#Wilcoxon test
ERN_amp_wil <- wilcox.test(df_ERN_peak$Amp_E, df_ERN_peak$Amp_M, paired=TRUE)  


ERN_peak_amp <- df_ERN_peak$Amp_E
ERN_peak_amp[10:18] <- df_ERN_peak$Amp_M 
group <- 1:18
group[1:9] <- 1
group[9:18] <- 2
df_ERN_peak_amp_plot <- as.data.frame(cbind(ERN_peak_amp, group))
df_ERN_peak_amp_plot$group <- as.factor(df_ERN_peak_amp_plot$group)

ERN_amp_flig <- fligner.test(ERN_peak_amp ~ group, data = df_ERN_peak_amp_plot)

pirateplot(formula = ERN_peak_amp~group, #which variables are you using
           data = df_ERN_peak_amp_plot,
           theme = 0, 
           main = "ERN Peak Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Peak Amplitude in micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-16, 3, by = 3)) #set the numbers on the y axis

```  
 
The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r ERN_amp_median_e`     
  
**Median Mobita =** `r ERN_amp_median_m`  

**Wilcoxon:** V = `r ERN_amp_wil$statistic`, p = `r ERN_amp_wil$p.value`, Bonferroni p = `r ERN_amp_wil$p.value*14`  
  
**Fligner-Killeen:** X^2^ = `r ERN_amp_flig$statistic`, p = `r ERN_amp_flig$p.value`, Bonferroni p = `r ERN_amp_flig$p.value*14`
  
******  
    
  
  
# 
# Exploratory analysis - ERN shifted  
  
Is it the case that the difference disappears once the mean amplitude window is moved back?  
  
```{r ERN shift, eval=TRUE, echo=FALSE,  warning=FALSE}

df_ERN_shift <- read.csv('ERN_M_shift.csv')  
#fetch the EasyCap data that was already used earlier 
df_ERN_easycap <- read.csv('ERN.csv')
df_ERN_easycap <- df_ERN_easycap[,c(2:3,5)]  

#merge these data frames
df_ERN_shift <- merge(df_ERN_shift, df_ERN_easycap, by="Mobita")

#remove participant 9 as they only had 5 trials available for comparison 9it was 4 before but the merge() function reaordered it)
df_ERN_shift <- df_ERN_shift[-9,]

#create difference waves 
# EasyCap
df_ERN_shift <- mutate(df_ERN_shift, dif_E = Err_Cz_E - Corr_Cz_E)
#Mobita
df_ERN_shift <- mutate(df_ERN_shift, dif_M = Err_Cz_M_shift - Corr_Cz_M_shift)

#Median for the difference wave EasyCap
median(df_ERN_shift$dif_E)
#Median for the difference wave Mobita
median(df_ERN_shift$dif_M)


#Wilcoxon test
wilcox.test(df_ERN_shift$dif_E, df_ERN_shift$dif_M, paired=TRUE)  

ERN_shift <- df_ERN_shift$dif_E
ERN_shift[10:18] <- df_ERN_shift$dif_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_ERN_shift_plot <- as.data.frame(cbind(ERN_shift, group))
df_ERN_shift_plot$group <- as.factor(df_ERN_shift_plot$group)

pirateplot(formula = ERN_shift~group, #which variables are you using
           data = df_ERN_shift_plot,
           theme = 0, 
           main = "ERN Mean Amplitude Per System (shifted)", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Mean Amplitude in Micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-12, 5, by = 4)) #set the numbers on the y axis

```
  
The differences in distribution disappear and the test can no longer provide evidence that there is a difference between the mean ERN amplitudes of both systems.
  
  
**ERN Plots**  
  
![Plots](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\ERN.jpg)






## **Rejected ICA components**    
Firstly, it will be calculated whether there is a significant difference between the number of trials rejected for each system.  
  
-  Median for Easy Cap  
-  Median for Mobita  
-  Wilcoxon test results  
  
```{r ICA comp prep, eval=TRUE, echo=FALSE,  warning=FALSE}

# Put the means of both systems in one data frame to be used for plots
rej_comp <- df_preproc$E_Rej_Comp
rej_comp[11:20] <- df_preproc$M_Rej_Comp 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_rej_comp <- as.data.frame(cbind(rej_comp, group))
df_rej_comp$group <- as.factor(df_rej_comp$group)



median(df_preproc$E_Rej_Comp)
median(df_preproc$M_Rej_Comp)

wilcox.test(df_preproc$E_Rej_Comp, df_preproc$M_Rej_Comp,paired=TRUE)
``` 
  


