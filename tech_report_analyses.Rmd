---
title: "Technical Report Analyses"
author: "Marta Topor"
date: "12/09/2021"
output: word_document
editor_options: 
  chunk_output_type: inline
---


```{r WD, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Set-up the workspace and load the data
setwd("C:/Users/marta/OneDrive - University of Surrey/Documents/All working docs/PhD/Tech Report/EasyCap_Mobita_Report")
library(tidyverse)
library(yarrr)
library(rstatix)
library(coin)
library(wmwpow)
library(jmv)
```


# Comparison of high and low frequecy noise in raw data  
  
The first part of analysis assesses the noise in the data before any preprocessing was applied. This information can be used to assess the quality of recorded data. We can especially pay attention to low frequency noise which may lead to drifts in the data and 50Hz noise which is an important indication of noise especially for Mobita where impedence could not be tested.  
  
******  
  
## **0.1-2Hz**    

```{r low freq, eval=TRUE, echo=FALSE}
#import data
df_raw_low <- read.csv("raw_2Hz_all.csv")
#remove participant info
df_raw_low <- df_raw_low[,-c(1,2)]

#import Theta frequency data
# Select EasyCap data and log transform
E_chans_low <- as.data.frame(df_raw_low[1:28])
E_chans_low_log <- as.data.frame(lapply(E_chans_low, log))
E_chans_low_log$mean_E <- rowMeans(E_chans_low_log)

# Select Mobita data and log transform
M_chans_low <- as.data.frame(df_raw_low[29:56])
M_chans_low_log <- as.data.frame(lapply(M_chans_low, log))
M_chans_low_log$mean_M <- rowMeans(M_chans_low_log)

# put the means of both systems in one data frame to be used for plots
all_chans_low <- E_chans_low_log$mean_E
all_chans_low[11:20] <- M_chans_low_log$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_low <- as.data.frame(cbind(all_chans_low, group))
df_means_low$group <- as.factor(df_means_low$group)
```
  
**Results**  
  
- Pirate Plot, the box indicates the IQR and median 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Wilcoxon test result 
- Bayes Factor  
- Fligner-Killeen test for homogeneity of variance 
  
```{r low freq results, eval=TRUE, echo=FALSE, message=FALSE, message=FALSE} 
#calculate medians and IQRs
raw_low_median_e <- median(E_chans_low_log$mean_E)
raw_low_iqr_e <- IQR(E_chans_low_log$mean_E)

raw_low_median_m <- median(M_chans_low_log$mean_M)
raw_low_iqr_m <- IQR(M_chans_low_log$mean_M)

#Test of central tendency differences
raw_low_wil <- wilcox.test(E_chans_low_log$mean_E, M_chans_low_log$mean_M,paired=TRUE)
#Wilcoxon effect size using the plot data structure
raw_low_es <- wilcox_effsize(df_means_low, all_chans_low ~ group, paired=TRUE)
  
#BF calculation on the Wilcoxon
BF_means_low <- as.data.frame(cbind(E_chans_low_log$mean_E, M_chans_low_log$mean_M))
BF_raw_low <- jmv::ttestPS(BF_means_low, pairs = list(
                    list(i1 = "V1", i2 = "V2")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)
       

#Test of homogeneity of variances
raw_low_flig <- fligner.test(all_chans_low ~ group, data = df_means_low)

#Individual differences plot
pirateplot(formula = all_chans_low~group, #which variables are you using
           data = df_means_low,
           theme = 0, 
           main = "0.1 - 2 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-1, 4, by = 1)) #set the numbers on the y axis

```

There is a significant difference in variance between EasyCap and Mobita for for the Fligner-Killeen test.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r raw_low_median_e`(`r raw_low_iqr_e`)  
**Median for Mobita:** `r raw_low_median_m`(`r raw_low_iqr_m`)  
  
**Wilcoxon:** V = `r raw_low_wil$statistic`, p = `r raw_low_wil$p.value`, Bonferroni p = `r raw_low_wil$p.value*8`, r = `r raw_low_es$effsize` (`r raw_low_es$magnitude`)    
  
**Fligner-Killeen:** X^2^ = `r raw_low_flig$statistic`, p = `r raw_low_flig$p.value`, Bonferroni p = `r raw_low_flig$p.value*8` 
  
**BF** 
```{r BF_raw_low}
BF_raw_low$ttest
```
  
******  
  
  

## **49-51Hz**    
  

```{r load raw high freq, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_raw_high <- read.csv("raw_50Hz_all.csv")

#remove participant info
df_raw_high <- df_raw_high[,-c(1,2)]

# Select EasyCap data and log transform
E_chans_high <- as.data.frame(df_raw_high[1:28])
E_chans_high_log <- as.data.frame(lapply(E_chans_high, log))
E_chans_high_log$mean_E <- rowMeans(E_chans_high_log)

# Select Mobita data and log transform
M_chans_high <- as.data.frame(df_raw_high[29:56])
M_chans_high_log <- as.data.frame(lapply(M_chans_high, log))
M_chans_high_log$mean_M <- rowMeans(M_chans_high_log)

# Put the means of both systems in one data frame to be used for plots
all_chans_high <- E_chans_high_log$mean_E
all_chans_high[11:20] <- M_chans_high_log$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_high <- as.data.frame(cbind(all_chans_high, group))
df_means_high$group <- as.factor(df_means_high$group)

```
  
**Descriptive statistics, Wilcoxon test and plot:**  
  
- Pirate Plot with IQR and median 
- Median for EasyCap 
- Median for Mobita 
- Wilcoxon test result
- Bayes Factor
- Fligner-Killeen test 
    

```{r high freq results, eval=TRUE, echo=FALSE, message=FALSE}
#calculate medians and IQRs
raw_high_median_e <- median(E_chans_high_log$mean_E)
raw_high_iqr_e <- IQR(E_chans_high_log$mean_E)

raw_high_median_m <- median(M_chans_high_log$mean_M)
raw_high_iqr_m <- IQR(M_chans_high_log$mean_M)

#Test of central tendency differences
raw_high_wil <- wilcox.test(E_chans_high_log$mean_E, M_chans_high_log$mean_M,paired=TRUE)
#use the plot data structure to calculate the Wilcoxon effect size
raw_high_es <- wilcox_effsize(df_means_high, all_chans_high ~ group, paired=TRUE)
  
#BF calculation on the Wilcoxon
BF_means_high <- as.data.frame(cbind(E_chans_high_log$mean_E, M_chans_high_log$mean_M))
BF_raw_high <- jmv::ttestPS(BF_means_high, pairs = list(
                    list(i1 = "V1", i2 = "V2")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)
 
#Test of homogeneity of variances
raw_high_flig <- fligner.test(all_chans_high ~ group, data = df_means_high)

pirateplot(formula = all_chans_high~group, #which variables are you using
           data = df_means_high,
           theme = 0, 
           main = "49 - 51 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-9, -1, by = 1)) #set the numbers on the y axis


```
  
There is a significant difference in variance between EasyCap and Mobita for for the Fligner-Killeen test.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r raw_high_median_e`(`r raw_high_iqr_e`)    
**Median for Mobita:** `r raw_high_median_m`(`r raw_high_iqr_m`)  
  
**Wilcoxon:** V = `r raw_high_wil$statistic`, p = `r raw_high_wil$p.value`, Bonferroni p = `r raw_high_wil$p.value*8`, r = `r raw_high_es$effsize` (`r raw_high_es$magnitude`)    
  
**Fligner-Killeen:** X^2^ = `r raw_high_flig$statistic`, p = `r raw_high_flig$p.value`, Bonferroni p = `r raw_high_flig$p.value*8`  
  
**BF** 
```{r BF_raw_high}
BF_raw_high$ttest
```

******  
  
  
**Raw Freq Plot Log-Transformed 0-60Hz**  
  
![Raw_Freq](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\fig1_raw_freq.jpg)  
  
  
# 
# Comparison of noise during and after pre-processing  
In this part data will be analysed to compare artefacts which were removed during pre-processing. Then noise metrics SNR and RMS will be compared between the two systems. Lastly, 0.1-2Hz and 49-51Hz power will be compared between the systems again.  
  
******
  
```{r pre-proc data, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_preproc <- read.csv("pre_processing_data.csv")

```
  
## **0.1-2Hz**    

```{r low freq processed, eval=TRUE, echo=FALSE}
#Import data
df_range_low_c <- read.csv("range_2Hz_all.csv")
#remove participant info
df_range_low_c <- df_range_low_c[,-c(1,2)]

# Select EasyCap data and log transform
E_chans_low_c <- as.data.frame(df_range_low_c[1:28])
E_chans_low_log_c <- as.data.frame(lapply(E_chans_low_c, log))
E_chans_low_log_c$mean_E <- rowMeans(E_chans_low_log_c)

# Select Mobita data and log transform
M_chans_low_c <- as.data.frame(df_range_low_c[29:56])
M_chans_low_log_c <- as.data.frame(lapply(M_chans_low_c, log))
M_chans_low_log_c$mean_M <- rowMeans(M_chans_low_log_c)

# put the means of both systems in one data frame to be used for plots
all_chans_low_c <- E_chans_low_log_c$mean_E
all_chans_low_c[11:20] <- M_chans_low_log_c$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_low_c <- as.data.frame(cbind(all_chans_low_c, group))
df_means_low_c$group <- as.factor(df_means_low_c$group)
```
  
**Descriptive statistics, Wilcoxon test and plot:**  
  
- Pirate Plot, the box indicates the IQR and median 
- Median for EasyCap 
- Median for Mobita 
- Wilcoxon test result 
- Bayes Factor  
- Fligner-Killeen test 
   
  
```{r low freq results processed, eval=TRUE, echo=FALSE, message=FALSE}  
#Calculate medians and IQRs
range_low_median_e <- median(E_chans_low_log_c$mean_E)
range_low_iqr_e <- IQR(E_chans_low_log_c$mean_E)

range_low_median_m <- median(M_chans_low_log_c$mean_M)
range_low_iqr_m <- IQR(M_chans_low_log_c$mean_M)

#Test of central tendency difference 
range_low_wil <- wilcox.test(E_chans_low_log_c$mean_E, M_chans_low_log_c$mean_M,paired=TRUE)
#calculate the Wilcoxon effect size using the data structure for plotting
range_low_es <- wilcox_effsize(df_means_low_c, all_chans_low_c ~ group, paired=TRUE)
  
#BF calculation on the Wilcoxon
BF_means_low_c <- as.data.frame(cbind(E_chans_low_log_c$mean_E, M_chans_low_log_c$mean_M))
BF_cleaned_low <- jmv::ttestPS(BF_means_low_c, pairs = list(
                    list(i1 = "V1", i2 = "V2")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Test of homogeneity of variance 
range_low_flig <- fligner.test(all_chans_low_c ~ group, data = df_means_low_c)

#individual differences plot
pirateplot(formula = all_chans_low_c~group, #which variables are you using
           data = df_means_low_c,
           theme = 0, 
           main = "0.1 - 2 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(3, 9, by = 1)) #set the numbers on the y axis

```
    
    
There are no significant results in the data.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r range_low_median_e`(`r range_low_iqr_e`)  
**Median for Mobita:** `r range_low_median_m`(`r range_low_iqr_m`)  
  
**Wilcoxon:** V = `r range_low_wil$statistic`, p = `r range_low_wil$p.value`, Bonferroni p = `r range_low_wil$p.value*8`, r = `r range_low_es$effsize` (`r range_low_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r range_low_flig$statistic`, p = `r range_low_flig$p.value`, Bonferroni p = `r range_low_flig$p.value*8`  

**BF**  
```{r BF_cleaned_low}
BF_cleaned_low$ttest
```
  
******  
  
  
## **49-51Hz**    
  

```{r high freq processed, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_range_high <- read.csv("range_50Hz_all.csv")

#remove participant info
df_range_high <- df_range_high[,-c(1,2)]

# Select EasyCap data and log transform
E_chans_high_c <- as.data.frame(df_range_high[1:28])
E_chans_high_log_c <- as.data.frame(lapply(E_chans_high_c, log))
E_chans_high_log_c$mean_E <- rowMeans(E_chans_high_log_c)

# Select Mobita data and log transform
M_chans_high_c <- as.data.frame(df_range_high[29:56])
M_chans_high_log_c <- as.data.frame(lapply(M_chans_high_c, log))
M_chans_high_log_c$mean_M <- rowMeans(M_chans_high_log_c)

# Put the means of both systems in one data frame to be used for plots
all_chans_high_c <- E_chans_high_log_c$mean_E
all_chans_high_c[11:20] <- M_chans_high_log_c$mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_means_high_c <- as.data.frame(cbind(all_chans_high_c, group))
df_means_high_c$group <- as.factor(df_means_high_c$group)

```
  
**Descriptive statistics, Wilcoxon test and plot:**  
  
- Piate Plot with IQR and median 
- Median for EasyCap 
- Median for Mobita 
- Wilcoxon test result 
- Bayes Factor  
- Fligner-Killeen test 

```{r high freq results processed, eval=TRUE, echo=FALSE, message=FALSE}
#Calculate medians and IQRs
range_high_median_e <- median(E_chans_high_log_c$mean_E)
range_high_iqr_e <- IQR(E_chans_high_log_c$mean_E)

range_high_median_m <- median(M_chans_high_log_c$mean_M)
range_high_iqr_m <- IQR(M_chans_high_log_c$mean_M)

# Test of central tendency differences
range_high_wil <- wilcox.test(E_chans_high_log_c$mean_E, M_chans_high_log_c$mean_M,paired=TRUE)
# Caluclate the Wilcoxon effect size using the plot data structure
range_high_es <- wilcox_effsize(df_means_high_c, all_chans_high_c ~ group, paired=TRUE)

#BF calculation on the Wilcoxon
BF_means_high_c <- as.data.frame(cbind(E_chans_high_log_c$mean_E, M_chans_high_log_c$mean_M))
BF_cleaned_high <- jmv::ttestPS(BF_means_high_c, pairs = list(
                    list(i1 = "V1", i2 = "V2")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Test of homogeneity of variances
range_high_flig <- fligner.test(all_chans_high_c ~ group, data = df_means_high_c)

#Individual differences plot
pirateplot(formula = all_chans_high_c~group, #which variables are you using
           data = df_means_high_c,
           theme = 0, 
           main = "49 - 51 Hz Power", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Power Log Transformed", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-7, -3, by = 1)) #set the numbers on the y axis


```

There are no significant results in the data.  
Bonferroni correction x8 as there are 2 tests for each of the 2 frequency bands at 2 time points (2 * 2 * 2) 
  
**Median for EasyCap:** `r range_high_median_e`(`r range_high_iqr_e`)  
**Median for Mobita:** `r range_high_median_m`(`r range_high_iqr_m`)  
  
**Wilcoxon:** V = `r range_high_wil$statistic`, p = `r range_high_wil$p.value`, Bonferroni p = `r range_high_wil$p.value*8`, r = `r range_high_es$effsize` (`r range_high_es$magnitude`)   
  
**Fligner-Killeen:** X^2^ = `r range_high_flig$statistic`, p = `r range_high_flig$p.value`, Bonferroni p = `r range_high_flig$p.value*8`  
  
**BF**  
```{r BF_cleaned_high}
BF_cleaned_high$ttest
```

******  
  

**Raw Freq Plot Log-Transformed 0-60Hz**  
  
![Range_Freq](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\fig2_range_freq.jpg)  

  
******
  
## **Rejected artefactual trials**  
There were three types of trials extracted for the analyses in this study. Stimulus locked trials, response locked trials with correct responses and response locked trials with incorrect responses. Proportion of rejected trials was calculated only for the stimulus-locked trials as the total number of trials was the largest in this type whereas for the response-locked trials, the total number was split (correct/incorrect).    
  
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Bayes Factor  
- Fligner-Killeen test 

  
```{r artefacts calculations, eval=TRUE, echo=FALSE,  warning=FALSE}

# Calculate the total trials for stimulus-locked trials for EasyCap
df_preproc <- mutate(df_preproc, E_Stim_Total = E_AllEp + E_Rej_AllEp)
#Calculate the proportion of rejected trials
df_preproc <- mutate(df_preproc, E_Stim_Rej_p = (E_Rej_AllEp/E_Stim_Total)*100)

# Calculate the total trials for stimulus-locked trials for Mobita
df_preproc <- mutate(df_preproc, M_Stim_Total = M_AllEp + M_Rej_AllEp)
#Calculate the proportion of rejected trials
df_preproc <- mutate(df_preproc, M_Stim_Rej_p = (M_Rej_AllEp/M_Stim_Total)*100)
  
#EasyCap Median
stim_rej_median_e <- median(df_preproc$E_Stim_Rej_p)
stim_rej_iqr_e <- IQR(df_preproc$E_Stim_Rej_p)
#Mobita Median
stim_rej_median_m <- median (df_preproc$M_Stim_Rej_p)
stim_rej_iqr_m <- IQR(df_preproc$M_Stim_Rej_p)

#Wilcoxon test
stim_rej_wil <- wilcox.test(df_preproc$E_Stim_Rej_p, df_preproc$M_Stim_Rej_p,paired=TRUE)  

#BF calculation on the Wilcoxon
BF_art_rej <- jmv::ttestPS(df_preproc, pairs = list(
                    list(i1 = "E_Stim_Rej_p", i2 = "M_Stim_Rej_p")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)


# Put the rejection rates of both systems in one data frame to be used for plots
rej_art <- df_preproc$E_Stim_Rej_p
rej_art[11:20] <- df_preproc$M_Stim_Rej_p 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_rej_art <- as.data.frame(cbind(rej_art, group))
df_rej_art$group <- as.factor(df_rej_art$group)

#Fligner test of variance
stim_rej_flig <- fligner.test(rej_art ~ group, data = df_rej_art)

#Calculate the effect size for Wilcoxon using the plot data structure
stim_rej_es <- wilcox_effsize(df_rej_art, rej_art ~ group, paired=TRUE)

#plot
pirateplot(formula = rej_art~group, #which variables are you using
           data = df_rej_art,
           theme = 0, 
           main = "Artefact Rejection", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Proportion of Rejected Stimulus-Locked Trials", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(0, 28, by = 4)) #set the numbers on the y axis


``` 
  
Both, the Wilcoxon and the Fligner-Killeen test are significant.  
Bonferroni correction x2 as there are 2 tests looking at artefact rejection in the dataset.    
  
**Median for EasyCap:** `r stim_rej_median_e`(`r stim_rej_iqr_e`)  
**Median for Mobita:** `r stim_rej_median_m`(`r stim_rej_iqr_m`)  
  
**Wilcoxon:** V = `r stim_rej_wil$statistic`, p = `r stim_rej_wil$p.value`, Bonferroni p = `r stim_rej_wil$p.value*2`, r = `r stim_rej_es$effsize` (`r stim_rej_es$magnitude`)
  
**Fligner-Killeen:** X^2^ = `r stim_rej_flig$statistic`, p = `r stim_rej_flig$p.value`, Bonferroni p = `r stim_rej_flig$p.value*2`  
  
**BF**
```{r BF_art_rej}
BF_art_rej$ttest
```
  
******  
  
  
      
## **Signal to Noise Ratio (SNR)**  
The SNR was also extracted from stimulus-locked trials. A subset of electrodes was chosen which excluded electrodes on the edges of the caps which are generally more prone to noise. The final electrode subset included:  F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4.  
  
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Bayes Factor
- Wilcoxon test results 
- Fligner-Killeen test 
  
  

```{r SNR, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}
# Prepare the data frames for selecting the electrodes of interest

# EasyCap
# Transopse
df_SNR_E <- read.csv('SNR_E.csv')
df_SNR_E <- as.data.frame(t(df_SNR_E))
#Column names
colnames(df_SNR_E) <- c('Fp1_E', 'Fp2_E', 'F7_E', 'F3_E', 'Fz_E', 'F4_E', 'F8_E', 'FC5_E', 'FC1_E', 'FC2_E', 'FC6_E', 'T7_E', 'C3_E', 'Cz_E', 'C4_E', 'T8_E', 'CP5_E', 'CP1_E', 'CP2_E', 'CP6_E', 'P7_E', 'P3_E', 'Pz_E', 'P4_E', 'P8_E', 'O1_E', 'O2_E')
df_SNR_E <- df_SNR_E[-1,]
#Select electrodes
df_SNR_E_sub <- select(df_SNR_E, contains(c('F3', 'Fz', 'F4', 'FC5', 'FC1', 'FC2', 'FC6', 'C3', 'Cz', 'C4', 'CP5', 'CP1', 'CP2', 'CP6', 'P3', 'Pz', 'P4')))
# Calculate row means
df_SNR_E_sub <- as.data.frame(lapply(df_SNR_E_sub, as.numeric))
df_SNR_E_sub$SNR_mean_E <- rowMeans(df_SNR_E_sub)
#Add a counting column
df_SNR_E_sub$ncount <- 1:nrow(df_SNR_E_sub)
  

# Mobita
# Transpose
df_SNR_M <- read.csv('SNR_M.csv')
df_SNR_M <- as.data.frame(t(df_SNR_M))
# Column Names
colnames(df_SNR_M) <- c('Fp1_M', 'Fp2_M', 'F7_M', 'F3_M', 'Fz_M', 'F4_M', 'F8_M', 'FC5_M', 'FC1_M', 'FC2_M', 'FC6_M', 'T7_M', 'C3_M', 'Cz_M', 'C4_M', 'T8_M', 'CP5_M', 'CP1_M', 'CP2_M', 'CP6_M', 'P7_M', 'P3_M', 'Pz_M', 'P4_M', 'P8_M', 'O1_M', 'O2_M')
df_SNR_M <- df_SNR_M[-1,] 
#Select electrodes
df_SNR_M_sub <- select(df_SNR_M, contains(c('F3', 'Fz', 'F4', 'FC5', 'FC1', 'FC2', 'FC6', 'C3', 'Cz', 'C4', 'CP5', 'CP1', 'CP2', 'CP6', 'P3', 'Pz', 'P4')))
# Calculate row means
df_SNR_M_sub <- as.data.frame(lapply(df_SNR_M_sub, as.numeric))
df_SNR_M_sub$SNR_mean_M <- rowMeans(df_SNR_M_sub)
#Add a counting column
df_SNR_M_sub$ncount <- 1:nrow(df_SNR_M_sub)


# merge the two data frames
df_SNR_final <- merge(df_SNR_E_sub,df_SNR_M_sub,by="ncount")


#Median EasyCap
SNR_median_e <- median(df_SNR_final$SNR_mean_E)
SNR_iqr_e <- IQR(df_SNR_final$SNR_mean_E)
#Median Mobita
SNR_median_m <- median(df_SNR_final$SNR_mean_M)
SNR_iqr_m <- IQR(df_SNR_final$SNR_mean_M)

#Wilcoxon test
SNR_wil <- wilcox.test(df_SNR_final$SNR_mean_E, df_SNR_final$SNR_mean_M,paired=TRUE)

#BF calculation on the Wilcoxon
BF_snr <- jmv::ttestPS(df_SNR_final, pairs = list(
                    list(i1 = "SNR_mean_E", i2 = "SNR_mean_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Prepare the data to plot
SNR <- df_SNR_final$SNR_mean_E
SNR[11:20] <- df_SNR_final$SNR_mean_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_SNR_plot <- as.data.frame(cbind(SNR, group))
df_SNR_plot$group <- as.factor(df_SNR_plot$group) 

#calculate the effect size from the data frame prepared for plotting
SNR_es <- wilcox_effsize(df_SNR_plot, SNR ~ group, paired=TRUE)
  
#calculate the test of variance
SNR_flig <- fligner.test(SNR ~ group, data = df_SNR_plot)

#Plot
pirateplot(formula = SNR~group, #which variables are you using
           data = df_SNR_plot,
           theme = 0, 
           main = "Signal to Noise Ratio per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Signal to Noise Ratio", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(0.01, .18, by = 0.03)) #set the numbers on the y axis

```

The results are non-significant.  
Bonferroni correction x4 as there are 2 tests and 2 measures of noise (SNR & RMS).  
  
**Median for EasyCap:** `r SNR_median_e`(`r SNR_iqr_e`)  
**Median for Mobita:** `r SNR_median_m`(`r SNR_median_m`)  
  
**Wilcoxon:** V = `r SNR_wil$statistic`, p = `r SNR_wil$p.value`, Bonferroni p = `r SNR_wil$p.value*4`, r = `r SNR_es$effsize` (`r SNR_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r SNR_flig$statistic`, p = `r SNR_flig$p.value`, Bonferroni p = `r SNR_flig$p.value*4`  
  
  
**BF**
```{r BF_snr}
BF_snr$ttest
```
  
  
## **Root-Mean Square (RMS)**  
The RMS values were also extracted from stimulus-locked trials. A subset of electrodes was chosen which excluded electrodes on the edges of the caps which are generally more prone to noise. The final electrode subset included:  F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4.  
  
-  Pirate Plot 
-  Median (IQR) for Easy Cap 
-  Median (IQR) for Mobita 
-  Wilcoxon test results 
-  Flinger-Killeen test 
  
  
```{r RMS, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}

df_RMS <- read.csv('RMS.csv')  
  
#Median EasyCap
RMS_median_e <- median(df_RMS$RMS_E_subset)
RMS_iqr_e <- IQR(df_RMS$RMS_E_subset)
#Median Mobita
RMS_median_m <- median(df_RMS$RMS_M_subset)
RMS_iqr_m <- IQR(df_RMS$RMS_M_subset)

#Wilcoxon test
RMS_wil <- wilcox.test(df_RMS$RMS_E_subset, df_RMS$RMS_M_subset,paired=TRUE)  

#prepare the data for plotting 
RMS <- df_RMS$RMS_E_subset
RMS[11:20] <- df_RMS$RMS_M_subset 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_RMS_plot <- as.data.frame(cbind(RMS, group))
df_RMS_plot$group <- as.factor(df_RMS_plot$group)  

#run the fligner test of variance using the new data frame
RMS_flig <- fligner.test(RMS ~ group, data = df_RMS_plot)

#calculate the Wilcoxon effect size using the new data frame
RMS_es <- wilcox_effsize(df_RMS_plot, RMS ~ group, paired=TRUE)

#BF calculation on the Wilcoxon
BF_rms <- jmv::ttestPS(df_RMS, pairs = list(
                    list(i1 = "RMS_E_subset", i2 = "RMS_M_subset")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#plot the data 
pirateplot(formula = RMS~group, #which variables are you using
           data = df_RMS_plot,
           theme = 0, 
           main = "Root Mean Squared per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Signal to Noise Ratio in micro volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(7, 98, by = 10)) #set the numbers on the y axis

```

Fligner-Kileen test is significant for RMS between EasyCap and Mobita.  
Bonferroni correction x4 as there are 2 tests and 2 measures of noise (SNR & RS).  
  
**Median for EasyCap:** `r RMS_median_e`(`r RMS_iqr_e`)  
**Median for Mobita:** `r RMS_median_m`(`r RMS_iqr_m`)  
  
**Wilcoxon:** V = `r RMS_wil$statistic`, p = `r RMS_wil$p.value`, Bonferroni p = `r RMS_wil$p.value*4`,  r = `r RMS_es$effsize` (`r RMS_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r RMS_flig$statistic`, p = `r RMS_flig$p.value`, Bonferroni p = `r RMS_flig$p.value*4`  
  
**BF**
```{r BF_rms}
BF_rms$ttest
```


# 
# Comparison of frequency activity between the two systems  
  
******

## **Theta analysis**
```{r load data, eval=TRUE, echo=FALSE}

#import Theta frequency data
df_theta <- read.csv("FFT_range_theta_all.csv")

```

**1. Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems. (most positive activity)  
Select from a subset of the following electrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: Fz, F4, FC1, FC2  

```{r matched electrodes, eval=TRUE, echo=FALSE}
#select the matching electrodes
df_theta_matched <- df_theta
df_theta_matched <- select(df_theta_matched, starts_with(c("Fz", "F4", "FC1", "FC2")))

```


```{r theta average, eval=TRUE, echo=FALSE}
#make sure that the data are numeric
df_theta_matched <- as.data.frame(apply(df_theta_matched, 2, as.numeric))

# EasyCap
#Calculate avergaes and log transform
theta_E <- df_theta_matched
theta_E <- select(df_theta_matched, contains("E")) 
                   
# add the averages to the dataframe
df_theta_matched$theta_av_E <- rowMeans(theta_E)

# log transform the data for ease of visual interpretation
df_theta_matched$theta_av_E_log <- log(df_theta_matched$theta_av_E)


# Mobita
#Calculate avergaes and log transform
theta_M <- df_theta_matched
theta_M <- select(df_theta_matched, contains("M")) 
                   
# add the averages to the dataframe
df_theta_matched$theta_av_M <- rowMeans(theta_M)

# log transform the data for ease of visual interpretation
df_theta_matched$theta_av_M_log <- log(df_theta_matched$theta_av_M)

```


**2. Results **   
  
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Correlation Plot 
- Wilcoxon Test 
- Bayes Factor
- Fligner-Killeen test  
  


```{r theta plot and test, eval=TRUE, echo=FALSE, message=FALSE}
#Calculate medians and IQRs
theta_median_e <- median(df_theta_matched$theta_av_E_log)
theta_iqr_e <- IQR(df_theta_matched$theta_av_E_log)

theta_median_m <- median(df_theta_matched$theta_av_M_log)
theta_iqr_m <- IQR(df_theta_matched$theta_av_M_log)

#Scatter plot
ggplot(df_theta_matched, aes(x=theta_av_E_log, y=theta_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

#Wilcoxon test
theta_wil <- wilcox.test(df_theta_matched$theta_av_E_log, df_theta_matched$theta_av_M_log, paired=TRUE)  

#BF calculation on the Wilcoxon
BF_theta <- jmv::ttestPS(df_theta_matched, pairs = list(
                    list(i1 = "theta_av_E_log", i2 = "theta_av_M_log")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#New data structure for further plotting and tests
all_theta_av <- df_theta_matched$theta_av_E_log
all_theta_av[11:20] <- df_theta_matched$theta_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_theta_av <- as.data.frame(cbind(all_theta_av, group))
df_theta_av$group <- as.factor(df_theta_av$group)  
  
#Fligner-Killeen test of variance 
theta_flig <- fligner.test(all_theta_av ~ group, data = df_theta_av)

#wilcoxon effect size using the new data structure
theta_es <- wilcox_effsize(df_theta_av, all_theta_av ~ group, paired=TRUE)

#Individual differences plots
pirateplot(formula = all_theta_av~group, #which variables are you using
           data = df_theta_av,
           theme = 0, 
           main = "Theta Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Theta Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-2, 3, by = 1)) #set the numbers on the y axis

```
  
  
There are no statistically significant results in the data.    
Bonferroni correction x8 as there are 4 frequency bands and 2 tests each.    
    
**Median EasyCap =** `r theta_median_e`(`r theta_iqr_e`)  
  
**Median Mobita =** `r theta_median_m`(`r theta_iqr_m`)  
  
**Wilcoxon:** V = `r theta_wil$statistic`, p = `r theta_wil$p.value`, Bonferroni p = `r theta_wil$p.value*8`, r = `r theta_es$effsize` (`r theta_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r theta_flig$statistic`, p = `r theta_flig$p.value`, Bonferroni p = `r theta_flig$p.value*8`  
  
**BF**
```{r BF_theta}
BF_theta$ttest
```

   
******
  
## **Alpha analysis** 
```{r load data alpha, eval=TRUE, echo=FALSE}

#import alpha frequency data
df_alpha <- read.csv("FFT_range_alpha_all.csv")

```

**Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems. (most positive activity)  
Select from a subset of the following elecrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: Fz, Pz, P4  
  

```{r matched electrodes alpha, eval=TRUE, echo=FALSE}
#select the matching electrodes
df_alpha_matched <- df_alpha
df_alpha_matched <- select(df_alpha, starts_with(c("Fz", "Pz", "P4")))


```


```{r alpha average, eval=TRUE, echo=FALSE}
#make sure that the data are numeric
df_alpha_matched <- as.data.frame(apply(df_alpha_matched, 2, as.numeric))

# EasyCap
#Calculate averages and log transform
alpha_E <- df_alpha_matched
alpha_E <- select(df_alpha_matched, contains("E")) 
                   
# add the averages to the dataframe
df_alpha_matched$alpha_av_E <- rowMeans(alpha_E)

# log transform the data for ease of visual interpretation
df_alpha_matched$alpha_av_E_log <- log(df_alpha_matched$alpha_av_E)


# Mobita
#Calculate averages and log transform
alpha_M <- df_alpha_matched
alpha_M <- select(df_alpha_matched, contains("M")) 
                   
# add the averages to the dataframe
df_alpha_matched$alpha_av_M <- rowMeans(alpha_M)

# log transform the data for ease of visual interpretation
df_alpha_matched$alpha_av_M_log <- log(df_alpha_matched$alpha_av_M)

```


**2. Results **   
  
- Correlation Plot 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Wilcoxon Test 
- Bayes Factor
- Fligner-Killeen test  
  
  
  
```{r alpha plot and test, eval=TRUE, echo=FALSE, message=FALSE}
#Calculate medians and IQRs
alpha_median_e <- median(df_alpha_matched$alpha_av_E_log)
alpha_iqr_e <- IQR(df_alpha_matched$alpha_av_E_log)

alpha_median_m <- median(df_alpha_matched$alpha_av_M_log)
alpha_iqr_m <- IQR(df_alpha_matched$alpha_av_M_log)

#Scatter Plot
ggplot(df_alpha_matched, aes(x=alpha_av_E_log, y=alpha_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

#Wilcoxon test of difference in central tendency
alpha_wil <- wilcox.test(df_alpha_matched$alpha_av_E_log, df_alpha_matched$alpha_av_M_log, paired=TRUE)  
  
#BF calculation on the Wilcoxon
BF_alpha <- jmv::ttestPS(df_alpha_matched, pairs = list(
                    list(i1 = "alpha_av_E_log", i2 = "alpha_av_M_log")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)
  
#New data structure for further plotting and tests
all_alpha_av <- df_alpha_matched$alpha_av_E_log
all_alpha_av[11:20] <- df_alpha_matched$alpha_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_alpha_av <- as.data.frame(cbind(all_alpha_av, group))
df_alpha_av$group <- as.factor(df_alpha_av$group)  

#use the new data structure for the variance test
alpha_flig <- fligner.test(all_alpha_av ~ group, data = df_alpha_av)

#wilcoxon effect size using the new data structure
alpha_es <- wilcox_effsize(df_alpha_av, all_alpha_av ~ group, paired=TRUE)

#Individual differences plot
pirateplot(formula = all_alpha_av~group, #which variables are you using
           data = df_alpha_av,
           theme = 0, 
           main = "Alpha Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Alpha Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-3, 1, by = 0.5)) #set the numbers on the y axis

```
  
There are no statistically significant results in the data.  
Bonferroni correction x8 as there are 4 frequency bands and 2 tests each.  
  
**Median EasyCap =** `r alpha_median_e`(`r alpha_iqr_e`)     
  
**Median Mobita =** `r alpha_median_m`(`r alpha_iqr_m`) 

**Wilcoxon:** V = `r alpha_wil$statistic`, p = `r alpha_wil$p.value`, Bonferroni p = `r alpha_wil$p.value*8`, r = `r alpha_es$effsize` (`r alpha_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r alpha_flig$statistic`, p = `r alpha_flig$p.value`, Bonferroni p = `r alpha_flig$p.value*8`  
  
**BF**
```{r BF_alpha}
BF_alpha$ttest
```
  
******  

## **Low Beta Analysis**
```{r load data lbeta, eval=TRUE, echo=FALSE}

#import lowe beta frequency data
df_lbeta <- read.csv("FFT_range_low_beta_all.csv")

```

**1. Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems. (least positive activity)  
Select from a subset the following elecrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: CP1, CP2, Pz  

```{r matched electrodes lbeta, eval=TRUE, echo=FALSE}
#select data for overlapping electrodes
df_lbeta_matched <- df_lbeta
df_lbeta_matched <- select(df_lbeta, starts_with(c("CP1", "CP2", "Pz")))

```


```{r lbeta average, eval=TRUE, echo=FALSE}
#Make sure that the data are numeric
df_lbeta_matched <- as.data.frame(apply(df_lbeta_matched, 2, as.numeric))

# EasyCap
#Calculate means and log transform
lbeta_E <- df_lbeta_matched
lbeta_E <- select(df_lbeta_matched, contains("E")) 
                   
# add the averages to the dataframe
df_lbeta_matched$lbeta_av_E <- rowMeans(lbeta_E)

# log transform the data for ease of visual interpretation
df_lbeta_matched$lbeta_av_E_log <- log(df_lbeta_matched$lbeta_av_E)


# Mobita
#Calculate means and log transform
lbeta_M <- df_lbeta_matched
lbeta_M <- select(df_lbeta_matched, contains("M")) 
                   
# add the averages to the dataframe
df_lbeta_matched$lbeta_av_M <- rowMeans(lbeta_M)

# log transform the data for ease of visual interpretation
df_lbeta_matched$lbeta_av_M_log <- log(df_lbeta_matched$lbeta_av_M)

```


**2. Results **   
  
- Correlation Plot 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Wilcoxcon Test 
- Bayes Factor
- Fligner-Killeen test  
  
  

```{r lbeta plot and test, eval=TRUE, echo=FALSE, message=FALSE}
#Calculate medians and IQRs
lbeta_median_e <- median(df_lbeta_matched$lbeta_av_E_log)
lbeta_iqr_e <- IQR(df_lbeta_matched$lbeta_av_E_log)

lbeta_median_m <- median(df_lbeta_matched$lbeta_av_M_log)
lbeta_iqr_m <- IQR(df_lbeta_matched$lbeta_av_M_log)

#Scatter plot
ggplot(df_lbeta_matched, aes(x=lbeta_av_E_log, y=lbeta_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

#Wilcoxon test of difference in central tendency
lbeta_wil <- wilcox.test(df_lbeta_matched$lbeta_av_E_log, df_lbeta_matched$lbeta_av_M_log, paired=TRUE)

#New data structure for further plots and tests
all_lbeta_av <- df_lbeta_matched$lbeta_av_E_log
all_lbeta_av[11:20] <- df_lbeta_matched$lbeta_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_lbeta_av <- as.data.frame(cbind(all_lbeta_av, group))
df_lbeta_av$group <- as.factor(df_lbeta_av$group)  

#test of variance using the new data structure
lbeta_flig <- fligner.test(all_lbeta_av ~ group, data = df_lbeta_av)

#wilcoxon effect size using the new data structure
lbeta_es <- wilcox_effsize(df_lbeta_av, all_lbeta_av ~ group, paired=TRUE)
  
#BF calculation on the Wilcoxon
BF_lbeta <- jmv::ttestPS(df_lbeta_matched, pairs = list(
                    list(i1 = "lbeta_av_E_log", i2 = "lbeta_av_M_log")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#plot of individual differences
pirateplot(formula = all_lbeta_av~group, #which variables are you using
           data = df_lbeta_av,
           theme = 0, 
           main = "Low Beta Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="Low Beta Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-4.5, 0, by = 0.5)) #set the numbers on the y axis

```

There are no statistically significant results in the data.  
Bonferroni correction x8 as there are 4 frequency bands and 2 tests each.  
  
**Median EasyCap =** `r lbeta_median_e`(`r lbeta_iqr_e`)  
  
**Median Mobita =** `r lbeta_median_m`(`r lbeta_iqr_m`)  

**Wilcoxon:** V = `r lbeta_wil$statistic`, p = `r lbeta_wil$p.value`, Bonferroni p = `r lbeta_wil$p.value*8`, r = `r lbeta_es$effsize` (`r lbeta_es$magnitude`)   
  
**Fligner-Killeen:** X^2^ = `r lbeta_flig$statistic`, p = `r lbeta_flig$p.value`, Bonferroni p = `r lbeta_flig$p.value*8`
  
**BF**
```{r BF_lbeta}
BF_lbeta$ttest
```
  
******    
  
  
## **High Beta Analysis**
```{r load data hbeta, eval=TRUE, echo=FALSE}

#import high beta frequency data
df_hbeta <- read.csv("FFT_range_high_beta_all.csv")

```

**Electrode matching**  

Select the electrodes that were identified to have strongest activity for theta band and which are overlapping between the two systems. (least positive activity)  
Select from a subset of the following electrodes only:  
F3, Fz, F4, FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6, P3, Pz, P4  
The above subset excludes electrodes located on the edges of the cap which are prone to noise and extreme values.  
  
Overlapping electrodes: CP1, CP2, Pz, P4   

```{r matched electrodes hbeta, eval=TRUE, echo=FALSE}
#Select the overlapping electrodes
df_hbeta_matched <- df_hbeta
df_hbeta_matched <- select(df_hbeta, starts_with(c("CP1", "CP2", "Pz", "P4")))

```


```{r hbeta average, eval=TRUE, echo=FALSE}
#Make sure that the data are numeric
df_hbeta_matched <- as.data.frame(apply(df_hbeta_matched, 2, as.numeric))

# EasyCap
#Calculate averages and log transform
hbeta_E <- df_hbeta_matched
hbeta_E <- select(df_hbeta_matched, contains("E")) 
                   
# add the averages to the dataframe
df_hbeta_matched$hbeta_av_E <- rowMeans(hbeta_E)

# log transform the data for ease of visual interpretation
df_hbeta_matched$hbeta_av_E_log <- log(df_hbeta_matched$hbeta_av_E)


# Mobita
#Calculate averages and log transform
hbeta_M <- df_hbeta_matched
hbeta_M <- select(df_hbeta_matched, contains("M")) 
                   
# add the averages to the dataframe
df_hbeta_matched$hbeta_av_M <- rowMeans(hbeta_M)

# log transform the data for ease of visual interpretation
df_hbeta_matched$hbeta_av_M_log <- log(df_hbeta_matched$hbeta_av_M)

```


**2. Results **   
  
- Correlation Plot 
- Pirate Plots 
- Median (IQR) for EasyCap 
- Median (IQR) for Mobita 
- Wilcoxon Test 
- Bayes Factor
- Fligner-Killeen test  
  

```{r hbeta plot and test, eval=TRUE, echo=FALSE, message=FALSE}
#Calculate medians and IQRs
hbeta_median_e <- median(df_hbeta_matched$hbeta_av_E_log)
hbeta_iqr_e <- IQR(df_hbeta_matched$hbeta_av_E_log)

hbeta_median_m <- median(df_hbeta_matched$hbeta_av_M_log)
hbeta_iqr_m <- IQR(df_hbeta_matched$hbeta_av_M_log)

#Scatter plot
ggplot(df_hbeta_matched, aes(x=hbeta_av_E_log, y=hbeta_av_M_log))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()

#Caluclate the Wilcoxon test for differences in central tendency
hbeta_wil <- wilcox.test(df_hbeta_matched$hbeta_av_E_log, df_hbeta_matched$hbeta_av_M_log, paired=TRUE)  

#New data structure for further plots and tests
all_hbeta_av <- df_hbeta_matched$hbeta_av_E_log
all_hbeta_av[11:20] <- df_hbeta_matched$hbeta_av_M_log
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_hbeta_av <- as.data.frame(cbind(all_hbeta_av, group))
df_hbeta_av$group <- as.factor(df_hbeta_av$group)  

#use the new data structure for the test of variance
hbeta_flig <- fligner.test(all_hbeta_av ~ group, data = df_hbeta_av)

#wilcoxon effect size using the new data structure
hbeta_es <- wilcox_effsize(df_hbeta_av, all_hbeta_av ~ group, paired=TRUE)

#Bayes factor calculation for Wilcoxon
BF_hbeta <- jmv::ttestPS(df_hbeta_matched, pairs = list(
                    list(i1 = "hbeta_av_E_log", i2 = "hbeta_av_M_log")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Individual differences plot
pirateplot(formula = all_hbeta_av~group, #which variables are you using
           data = df_hbeta_av,
           theme = 0, 
           main = "High Beta Power Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="High Beta Power Log", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "appletv", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-5, -1.5, by = 0.5)) #set the numbers on the y axis

```
  
There are no statistically significant results in the data.  
Bonferroni correction x8 as there are 4 frequency bands and 2 tests each.  
  
**Median EasyCap =** `r hbeta_median_e`(`r hbeta_iqr_e`)  
  
**Median Mobita =** `r hbeta_median_m`(`r hbeta_iqr_m`)  

**Wilcoxon:** V = `r hbeta_wil$statistic`, p = `r hbeta_wil$p.value`, Bonferroni p = `r hbeta_wil$p.value*8`, r = `r hbeta_es$effsize` (`r hbeta_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r hbeta_flig$statistic`, p = `r hbeta_flig$p.value`, Bonferroni p = `r hbeta_flig$p.value*8`
  
**BF**
```{r BF_hbeta}
BF_hbeta$ttest
```
******  



## **Frequency Topographies**  

![Plots](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\freq_topographies.jpg)


# 
# Comparison of Event-Related Potentials between the two systems 

## **P300**  
**Mean Amplitude**
  
- Correlation Plot 
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Bayes Factor
- Fligner-Killeen test  
  
  
```{r P300, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}
#Import P300 data
df_P300 <- read.csv('P300.csv')

#Median EasyCap
P300_median_e <- median(df_P300$Pz_E)
P300_iqr_e <- IQR(df_P300$Pz_E)

#Median Mobita
P300_median_m <- median(df_P300$Pz_M)
P300_iqr_m <- IQR(df_P300$Pz_M)

#Correlation plot
ggplot(df_P300, aes(x=Pz_E, y=Pz_M))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()


#Wilcoxon test
P300_wil <- wilcox.test(df_P300$Pz_E, df_P300$Pz_M, paired=TRUE)  

#Bayes factor calculation for Wilcoxon
BF_P300 <- jmv::ttestPS(df_P300, pairs = list(
                    list(i1 = "Pz_E", i2 = "Pz_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#New data structure for further plots and tests
P300 <- df_P300$Pz_E
P300[11:20] <- df_P300$Pz_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_P300_plot <- as.data.frame(cbind(P300, group))
df_P300_plot$group <- as.factor(df_P300_plot$group)

# Test of difference in variance using the new data structure
P300_flig <- fligner.test(P300 ~ group, data = df_P300_plot)

#Effect size for Wilcoxon using the new data structure
P300_es <- wilcox_effsize(df_P300_plot, P300 ~ group, paired=TRUE)

#Individual differences plot
pirateplot(formula = P300~group, #which variables are you using
           data = df_P300_plot,
           theme = 0, 
           main = "P300 Mean Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="P300 Mean Amplitude in Micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-2, 7, by = 3)) #set the numbers on the y axis

```
The results are non-significant. 
Bonferroni correction x12 as there are 2 types of ERPs with 6 tests used for each     

**Median EasyCap =** `r P300_median_e`(`r P300_iqr_e`)  
  
**Median Mobita =** `r P300_median_m`(`r P300_iqr_m`)  

**Wilcoxon:** V = `r P300_wil$statistic`, p = `r P300_wil$p.value`, Bonferroni p = `r P300_wil$p.value*12`, r = `r P300_es$effsize` (`r P300_es$magnitude`)   
  
**Fligner-Killeen:** X^2^ = `r P300_flig$statistic`, p = `r P300_flig$p.value`, Bonferroni p = `r P300_flig$p.value*12`  
  
**BF**
```{r BF_P300}
BF_P300$ttest
```
  
******  
 

  
**Latency**  

- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Fligner-Killeen test  
  

```{r P300 latency, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}
#the peaks are extracted from the difference wave already
df_P300_peak <- read.csv('P300_peak.csv')


#Median for the peak latency EasyCap
P300_lat_median_e <- median(df_P300_peak$Time_E)
P300_lat_iqr_e <- IQR(df_P300_peak$Time_E)

#Median for the peak latency Mobita
P300_lat_median_m <- median(df_P300_peak$Time_M)
P300_lat_iqr_m <- IQR(df_P300_peak$Time_M)

#Wilcoxon test
P300_lat_wil <- wilcox.test(df_P300_peak$Time_E, df_P300_peak$Time_M, paired=TRUE) 

#Bayes factor calculation for Wilcoxon
BF_P300_lt <- jmv::ttestPS(df_P300_peak, pairs = list(
                    list(i1 = "Time_E", i2 = "Time_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Make a new data structure for further plotting and tests
P300_peak <- df_P300_peak$Time_E
P300_peak[11:20] <- df_P300_peak$Time_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_P300_peak_plot <- as.data.frame(cbind(P300_peak, group))
df_P300_peak_plot$group <- as.factor(df_P300_peak_plot$group)

#Test of difference of variance using the new data structure
P300_lat_flig <- fligner.test(P300_peak ~ group, data = df_P300_peak_plot)

#Effect size for Wilcoxon using the new data structure
P300_lat_es <- wilcox_effsize(df_P300_peak_plot, P300_peak ~ group, paired=TRUE)

#Individual data plots
pirateplot(formula = P300_peak~group, #which variables are you using
           data = df_P300_peak_plot,
           theme = 0, 
           main = "P300 Peak Latency Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="P300 Peak Time in ms", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(266, 379, by = 10)) #set the numbers on the y axis

```  
  
The results are non-significant. 
Bonferroni correction x12 as there are 2 types of ERPs with 6 tests used for each     

**Median EasyCap =** `r P300_lat_median_e`(`r P300_lat_iqr_e`)  
  
**Median Mobita =** `r P300_lat_median_m`(`r P300_lat_iqr_m`)  

**Wilcoxon:** V = `r P300_lat_wil$statistic`, p = `r P300_lat_wil$p.value`, Bonferroni p = `r P300_lat_wil$p.value*12`, r = `r P300_lat_es$effsize` (`r P300_lat_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r P300_lat_flig$statistic`, p = `r P300_lat_flig$p.value`, Bonferroni p = `r P300_lat_flig$p.value*12`  
  
**BF**
```{r BF_P300_lt}
BF_P300_lt$ttest
```
  
******  
  
  
  
**Amplitude**  
  

- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Bayes Factor
- Fligner-Killeen test  
  
  
```{r P300 amplitude, eval=TRUE, echo=FALSE,  warning=FALSE}
#the peaks a re extracted from the difference wave already
df_P300_peak <- read.csv('P300_peak.csv')

#Median for the peak latency EasyCap
P300_amp_median_e <- median(df_P300_peak$Amp_E)
P300_amp_iqr_e <- IQR(df_P300_peak$Amp_E)

#Median for the peak latency Mobita
P300_amp_median_m <- median(df_P300_peak$Amp_M)
P300_amp_iqr_m <- IQR(df_P300_peak$Amp_M)
  
#Wilcoxon test
P300_amp_wil <- wilcox.test(df_P300_peak$Amp_E, df_P300_peak$Amp_M, paired=TRUE) 

#Bayes Factor calculation for Wilcoxon
BF_P300_amp <- jmv::ttestPS(df_P300_peak, pairs = list(
                    list(i1 = "Amp_E", i2 = "Amp_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#New data structure for further plotting and tests
P300_peak_amp <- df_P300_peak$Amp_E
P300_peak_amp[11:20] <- df_P300_peak$Amp_M 
group <- 1:20
group[1:10] <- 1
group[11:20] <- 2
df_P300_peak_amp_plot <- as.data.frame(cbind(P300_peak_amp, group))
df_P300_peak_amp_plot$group <- as.factor(df_P300_peak_amp_plot$group)

#Test of difference in variance using the new data structure
P300_amp_flig <- fligner.test(P300_peak_amp ~ group, data = df_P300_peak_amp_plot)
#Effect size for Wilcoxon using the new data structure
P300_amp_es <- wilcox_effsize(df_P300_peak_amp_plot, P300_peak_amp ~ group, paired=TRUE)

#Individual data plots
pirateplot(formula = P300_peak_amp~group, #which variables are you using
           data = df_P300_peak_amp_plot,
           theme = 0, 
           main = "P300 Peak Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="P300 Peak Amplitude in micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-3, 8, by = 3)) #set the numbers on the y axis

```  
 
The results are non-significant. 
Bonferroni correction x14 as there are 2 types of ERPs with 7 tests used for each     

**Median EasyCap =** `r P300_amp_median_e`(`r P300_amp_iqr_e`)  
  
**Median Mobita =** `r P300_amp_median_m`(`r P300_amp_iqr_m`)  

**Wilcoxon:** V = `r P300_amp_wil$statistic`, p = `r P300_amp_wil$p.value`, Bonferroni p = `r P300_amp_wil$p.value*12`, r = `r P300_amp_es$effsize` (`r P300_amp_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r P300_amp_flig$statistic`, p = `r P300_amp_flig$p.value`, Bonferroni p = `r P300_amp_flig$p.value*12`  
  
**BF**
```{r BF_P300_amp}
BF_P300_amp$ttest
```
  
******  
  

**P300 Plots**  
![Plots](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\P300.jpg)  
  
  
## **ERN**  
  
**Mean Amplitude** 

- Correlation Plot 
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Bayes Factor
- Fligner-Killeen test  
  

```{r ERN, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}
#Import ERN data
df_ERN <- read.csv('ERN.csv')
#remove participant 4 as they only had 5 trials available for comparison
df_ERN <- df_ERN[-4,]

#create difference waves 
# EasyCap
df_ERN <- mutate(df_ERN, dif_E = Err_Cz_E - Corr_Cz_E)
#Mobita
df_ERN <- mutate(df_ERN, dif_M = Err_Cz_M - Corr_Cz_M)

#Median for the difference wave EasyCap
ERN_median_e <- median(df_ERN$dif_E)
ERN_iqr_e <- IQR(df_ERN$dif_E)

#Median for the difference wave Mobita
ERN_median_m <- median(df_ERN$dif_M)
ERN_iqr_m <- IQR(df_ERN$dif_M)

#Correlation plot
ggplot(df_ERN, aes(x=dif_E, y=dif_M))+ 
  geom_point()+
  geom_smooth(method=lm, fullrange=TRUE)+
  theme_classic()


#Wilcoxon test
ERN_wil <- wilcox.test(df_ERN$dif_E, df_ERN$dif_M, paired=TRUE)  

#Bayes Factor calculation for Wilcoxon
BF_ERN <- jmv::ttestPS(df_ERN, pairs = list(
                    list(i1 = "dif_E", i2 = "dif_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Create a new data structure for plotting and further tests
ERN <- df_ERN$dif_E
ERN[10:18] <- df_ERN$dif_M 
group_ERN <- 1:18
group_ERN[1:9] <- 1
group_ERN[10:18] <- 2
df_ERN_plot <- as.data.frame(cbind(ERN, group_ERN))
df_ERN_plot$group_ERN <- as.factor(df_ERN_plot$group_ERN)

#Test of variance 
ERN_flig <- fligner.test(ERN ~ group_ERN, data = df_ERN_plot)

#Wilcoxon effect size
ERN_es <- wilcox_effsize(df_ERN_plot, ERN ~ group_ERN, paired=TRUE)

#Individual data plot
pirateplot(formula = ERN~group_ERN, #which variables are you using
           data = df_ERN_plot,
           theme = 0, 
           main = "ERN Mean Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Mean Amplitude in Micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-12, 6, by = 3)) #set the numbers on the y axis

```

The results are non-significant. 
Bonferroni correction x12 as there are 2 types of ERPs with 6 tests used for each     

**Median EasyCap =** `r ERN_median_e`(`r ERN_iqr_e`)     
  
**Median Mobita =** `r ERN_median_m`(`r ERN_iqr_m`)  
  
**Wilcoxon:** V = `r ERN_wil$statistic`, p = `r ERN_wil$p.value`, Bonferroni p = `r ERN_wil$p.value*12`, r = `r ERN_es$effsize` (`r ERN_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r ERN_flig$statistic`, p = `r ERN_flig$p.value`, Bonferroni p = `r ERN_flig$p.value*12`  
  
**BF**
```{r BF_ERN}
BF_ERN$ttest
```
  
  
******  
  
  
**Peak Latency**  

- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Bayes Factor
- Fligner-Killeen test  
  

```{r ERN latency, eval=TRUE, echo=FALSE,  warning=FALSE}
#the peaks are extracted from the difference wave already
df_ERN_peak <- read.csv('ERN_peak.csv')


#Median for the peak latency EasyCap
ERN_lat_median_e <- median(df_ERN_peak$Time_E)
ERN_lat_iqr_e <- IQR(df_ERN_peak$Time_E)

#Median for the peak latency Mobita
ERN_lat_median_m <- median(df_ERN_peak$Time_M)
ERN_lat_iqr_m <- IQR(df_ERN_peak$Time_M)

#Wilcoxon test
ERN_lat_wil <- wilcox.test(df_ERN_peak$Time_E, df_ERN_peak$Time_M, paired=TRUE)  

#Bayes Factor calculation for Wilcoxon
BF_ERN_lt <- jmv::ttestPS(df_ERN_peak, pairs = list(
                    list(i1 = "Time_E", i2 = "Time_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Create a new data structure for plots and further tests
ERN_peak <- df_ERN_peak$Time_E
ERN_peak[10:18] <- df_ERN_peak$Time_M 
group_ERN <- 1:18
group_ERN[1:9] <- 1
group_ERN[10:18] <- 2
df_ERN_peak_plot <- as.data.frame(cbind(ERN_peak, group_ERN))
df_ERN_peak_plot$group_ERN <- as.factor(df_ERN_peak_plot$group_ERN)

#test of variance
ERN_lat_flig <- fligner.test(ERN_peak ~ group_ERN, data = df_ERN_peak_plot)

#effect size for Wilcoxon
ERN_lat_es <- wilcox_effsize(df_ERN_peak_plot, ERN_peak ~ group_ERN, paired=TRUE)

#individual data plot
pirateplot(formula = ERN_peak~group_ERN, #which variables are you using
           data = df_ERN_peak_plot,
           theme = 0, 
           main = "ERN Peak Latency Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Peak Time in ms", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-26, 71, by = 10)) #set the numbers on the y axis

```  
  
The results are non-significant. 
Bonferroni correction x12 as there are 2 types of ERPs with 6 tests used for each     

**Median EasyCap =** `r ERN_lat_median_e`(`r ERN_lat_iqr_e`)  
  
**Median Mobita =** `r ERN_lat_median_m`(`r ERN_lat_iqr_m`)  

**Wilcoxon:** V = `r ERN_lat_wil$statistic`, p = `r ERN_lat_wil$p.value`, Bonferroni p = `r ERN_lat_wil$p.value*12`, r = `r ERN_lat_es$effsize` (`r ERN_lat_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r ERN_lat_flig$statistic`, p = `r ERN_lat_flig$p.value`, Bonferroni p = `r ERN_lat_flig$p.value*12`  
  
**BF**
```{r BF_ERN_lt}
BF_ERN_lt$ttest
```
  
******  


**Peak Amplitude**  
  
- Pirate Plot 
- Median (IQR) for Easy Cap 
- Median (IQR) for Mobita 
- Wilcoxon test results 
- Fligner-Killeen test  
  
```{r ERN amplitude, eval=TRUE, echo=FALSE,  warning=FALSE}
#the peaks are extracted from the difference wave already
df_ERN_peak <- read.csv('ERN_peak.csv')

#Median for the peak latency EasyCap
ERN_amp_median_e <- median(df_ERN_peak$Amp_E)
ERN_amp_iqr_e <- IQR(df_ERN_peak$Amp_E)

#Median for the peak latency Mobita
ERN_amp_median_m <- median(df_ERN_peak$Amp_M)
ERN_amp_iqr_m <- IQR(df_ERN_peak$Amp_M)

#Wilcoxon test
ERN_amp_wil <- wilcox.test(df_ERN_peak$Amp_E, df_ERN_peak$Amp_M, paired=TRUE)  

#Bayes Factor calculation for Wilcoxon
BF_ERN_amp <- jmv::ttestPS(df_ERN_peak, pairs = list(
                    list(i1 = "Amp_E", i2 = "Amp_M")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#New data structure for plotting and further tests
ERN_peak_amp <- df_ERN_peak$Amp_E
ERN_peak_amp[10:18] <- df_ERN_peak$Amp_M 
group_ERN <- 1:18
group_ERN[1:9] <- 1
group_ERN[10:18] <- 2
df_ERN_peak_amp_plot <- as.data.frame(cbind(ERN_peak_amp, group_ERN))
df_ERN_peak_amp_plot$group_ERN <- as.factor(df_ERN_peak_amp_plot$group_ERN)

#Test of variance
ERN_amp_flig <- fligner.test(ERN_peak_amp ~ group_ERN, data = df_ERN_peak_amp_plot)

#Wilcoxon effect size
ERN_amp_es <- wilcox_effsize(df_ERN_peak_amp_plot, ERN_peak_amp ~ group_ERN, paired=TRUE)

#Individual data plot
pirateplot(formula = ERN_peak_amp~group_ERN, #which variables are you using
           data = df_ERN_peak_amp_plot,
           theme = 0, 
           main = "ERN Peak Amplitude Per System", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="ERN Peak Amplitude in micro Volts", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(-16, 3, by = 3)) #set the numbers on the y axis

```  
 
The results are non-significant. 
Bonferroni correction x12 as there are 2 types of ERPs with 6 tests used for each     

**Median EasyCap =** `r ERN_amp_median_e`(`r ERN_amp_iqr_e`)  
  
**Median Mobita =** `r ERN_amp_median_m`(`r ERN_amp_iqr_m`)  

**Wilcoxon:** V = `r ERN_amp_wil$statistic`, p = `r ERN_amp_wil$p.value`, Bonferroni p = `r ERN_amp_wil$p.value*12`, r = `r ERN_amp_es$effsize` (`r ERN_amp_es$magnitude`)  
  
**Fligner-Killeen:** X^2^ = `r ERN_amp_flig$statistic`, p = `r ERN_amp_flig$p.value`, Bonferroni p = `r ERN_amp_flig$p.value*12`  
  
**BF**
```{r BF_ERN_amp}
BF_ERN_amp$ttest
```
  

**ERN Plots**  
  
![Plots](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\ERN.jpg)

****** 

## **Investigating why the P300 is shifed frontally**    
  
**EasyCap and Mobita P300 activity at Fz and Pz**  
EasyCap is in black and Mobita is in red.  

![P300 waves](C:\Users\marta\OneDrive - University of Surrey\Documents\All working docs\PhD\Tech Report\EasyCap_Mobita_Report\P300_fz_pz.jpg)  
  
Here the activity looks stronger for Fz in Mobita in comparison to Fz in EasyCap and in comparison to Mobita activity at Pz.  
  
  
**SNR distribution across different areas of electrodes**  
The electrodes will be divided into 3 areas and the mean SNR values for those areas will be compared using the Wilcoxon and Fligner-Killeen tests.  
  
Frontal: Fp1, F2p, F7, F3, Fz, F4, F8,   
Central: FC5, FC1, FC2, FC6, C3, Cz, C4, CP5, CP1, CP2, CP6  
Posterior: P7, P3, Pz, P4, P8, O1, O2 
  
```{r SNR distribution, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE}

#Make a new data frame where SNR data from EasyCap and Mobita will be combined. The name of the columns has to be the same so rename these first.

df_SNR_all <- df_SNR_E
colnames(df_SNR_all) <- c('Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'FC1', 'FC2', 'FC6', 'T7', 'C3', 'Cz', 'C4', 'T8', 'CP5', 'CP1', 'CP2', 'CP6', 'P7', 'P3', 'Pz', 'P4', 'P8', 'O1', 'O2') 

df_SNR_M_renamed <- df_SNR_M
colnames(df_SNR_M_renamed) <- c('Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8', 'FC5', 'FC1', 'FC2', 'FC6', 'T7', 'C3', 'Cz', 'C4', 'T8', 'CP5', 'CP1', 'CP2', 'CP6', 'P7', 'P3', 'Pz', 'P4', 'P8', 'O1', 'O2')

#Merge EasyCap and Mobita data into one data frame
df_SNR_all <- bind_rows(df_SNR_all, df_SNR_M_renamed)

# Make a new data frame for frontal electrodes and calculate the means
df_SNR_frontal <-  df_SNR_all[,c('Fp1', 'Fp2', 'F7', 'F3', 'Fz', 'F4', 'F8')]
df_SNR_frontal <- as.data.frame(lapply(df_SNR_frontal, as.numeric))
df_SNR_frontal$mean_frontal <- rowMeans(df_SNR_frontal)

# Make a new data frame for central electrodes and calculate the means
df_SNR_central <- df_SNR_all[,c('FC5','FC1', 'FC2', 'FC6','C3', 'Cz', 'C4','CP5', 'CP1', 'CP2', 'CP6')]
df_SNR_central <- as.data.frame(lapply(df_SNR_central, as.numeric))
df_SNR_central$mean_central <- rowMeans(df_SNR_central)

# Make a new data frame for posterior electrodes and calculate the means
df_SNR_posterior <- df_SNR_all[,c('P7', 'P3', 'Pz', 'P4', 'P8', 'O1', 'O2')]
df_SNR_posterior <- as.data.frame(lapply(df_SNR_posterior, as.numeric))
df_SNR_posterior$mean_posterior <- rowMeans(df_SNR_posterior)

#Add the means back to the main data frame
df_SNR_all$mean_frontal <- df_SNR_frontal$mean_frontal
df_SNR_all$mean_central <- df_SNR_central$mean_central
df_SNR_all$mean_posterior <- df_SNR_posterior$mean_posterior

#Prepare a new data frame with a layout suitable for plotting
SNR_areas <- 1:20
SNR_areas[1:20] <- df_SNR_frontal$mean_frontal
SNR_areas[21:40] <- df_SNR_central$mean_central
SNR_areas[41:60] <- df_SNR_posterior$mean_posterior

area <- rep("Frontal", 20)
area[21:40] <- rep("Central",20)
area[41:60] <- rep("Posterior",20)  
  
group_SNR <- rep(1, 10)
group_SNR[11:20] <- rep(2, 10)
group_SNR[21:30] <- rep(1, 10)
group_SNR[31:40] <- rep(2, 10)
group_SNR[41:50] <- rep(1, 10)
group_SNR[51:60] <- rep(2, 10)

df_SNR_areas <- as.data.frame(cbind(SNR_areas, area, group_SNR))
df_SNR_areas$SNR_areas <- as.numeric((df_SNR_areas$SNR_areas))

 
#individual data plot for all three electrode regions
pirateplot(formula = SNR_areas ~ area + group_SNR, #which variables are you using
           data = df_SNR_areas,
           theme = 0, 
           main = "SNR per area per system", #title of the graph
           par(cex.main = 1.2), #set the size of your title
           xlab="EEG System", #label of the x axis
           ylab="SNR values", #label of the y axis
           cex.lab = 1.2, #size of the axis labels
           pal = "basel", 
           inf.method = 'iqr', # IQR box
           avg.line.fun = median,
           bean.f.o = 0.5, # Bean fill darkness
           point.o = .3, # points darkness
           inf.f.o = .5, # Inference fill
           inf.b.o = .5, # Inference border
           avg.line.o = 0.7, # Average line darkness
           inf.f.col = "white", # Inf fill col
           inf.b.col = "black", # Inf border col
           avg.line.col = "black", # avg line col
           point.pch = 20, #point shape
           point.col = "black", #point colour
           point.cex = 1, #point size
           gl.col = "#FFCCFF", #gridlines and colour
           yaxt ="n", # remove the automatic scale on the axis Y
           quant = c(.05, .95) #set the quantile, here within 5% on each side to indicate outliers
           )
#here are some additional commands that add onto the plot
axis(2, at = seq(0.007, 0.190 , by = 0.015)) #set the numbers on the y axis

# Create vectors for the wilcoxon test
SNR_frontal_e <- df_SNR_all$mean_frontal[1:10]
SNR_frontal_m <- df_SNR_all$mean_frontal[11:20]

SNR_central_e <- df_SNR_all$mean_central[1:10]
SNR_central_m <- df_SNR_all$mean_central[11:20]

SNR_posterior_e <- df_SNR_all$mean_posterior[1:10]
SNR_posterior_m <- df_SNR_all$mean_posterior[11:20]

# Run the Wilcoxon tests
SNR_frontal_wil <- wilcox.test(SNR_frontal_e, SNR_frontal_m, paired=TRUE)  
SNR_central_wil <- wilcox.test(SNR_central_e, SNR_central_m, paired=TRUE) 
SNR_posterior_wil <- wilcox.test(SNR_posterior_e, SNR_posterior_m, paired=TRUE)

#Bayes Factor calculation for Wilcoxon
df_snr_front <- as.data.frame(cbind(SNR_frontal_e, SNR_frontal_m))
BF_snr_front <- jmv::ttestPS(df_snr_front, pairs = list(
                    list(i1 = "SNR_frontal_e", i2 = "SNR_frontal_m")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Bayes Factor calculation for Wilcoxon
df_snr_cent <- as.data.frame(cbind(SNR_central_e, SNR_central_m))
BF_snr_cent <- jmv::ttestPS(df_snr_cent, pairs = list(
                    list(i1 = "SNR_central_e", i2 = "SNR_central_m")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)

#Bayes Factor calculation for Wilcoxon
df_snr_post <- as.data.frame(cbind(SNR_posterior_e, SNR_posterior_m))
BF_snr_post <- jmv::ttestPS(df_snr_post, pairs = list(
                    list(i1 = "SNR_posterior_e", i2 = "SNR_posterior_m")),
                    students = FALSE,
                    bf = TRUE,
                    bfPrior = 0.7,
                    wilcoxon = TRUE)


#Prepare data for the Fligner tests  
df_SNR_frontal$group <- group
df_SNR_central$group <- group
df_SNR_posterior$group <- group
#Run the Fligner-Killeen tests
SNR_frontal_flig <- fligner.test(mean_frontal ~ group, data = df_SNR_frontal)
SNR_central_flig <- fligner.test(mean_central ~ group, data = df_SNR_central)
SNR_posterior_flig <- fligner.test(mean_posterior ~ group, data = df_SNR_posterior)

#Calculate Wilcoxon effect sizes using the data sructures prepared for Fligner
SNR_frontal_es <- wilcox_effsize(df_SNR_frontal, mean_frontal ~ group, paired=TRUE)
SNR_central_es <- wilcox_effsize(df_SNR_central, mean_central ~ group, paired=TRUE)
SNR_posterior_es <- wilcox_effsize(df_SNR_posterior, mean_posterior ~ group, paired=TRUE)

```

The results from Wilcoxon test are significant for the posterior electrodes. All other tests are non-significant.  
Because there are 4 other tests looking at noise in the data, p-value are be multiplied by 10.  
Bonferroni correction x10.  

**Frontal electrodes**  
EasyCap Median(IQR): `r median(SNR_frontal_e)`(`r IQR(SNR_frontal_e)`)  
Mobita Median(IQR): `r median(SNR_frontal_m)`(`r IQR(SNR_frontal_m)`)  
Wilcoxon: `r SNR_frontal_wil$statistic`, p-value = `r SNR_frontal_wil$p.value`, Bonferroni p-value: `r SNR_frontal_wil$p.value*10`, r = `r SNR_frontal_es$effsize` (`r SNR_frontal_es$magnitude`)  
Fligner-Killeen: `r SNR_frontal_flig$statistic`, p-value = `r SNR_frontal_flig$p.value`, Bonferroni p-value: `r SNR_frontal_flig$p.value*10`  
**BF**
```{r BF_ERN_front}
BF_snr_front$ttest
```
  
**Central electrodes**  
EasyCap Median(IQR): `r median(SNR_central_e)`(`r IQR(SNR_central_e)`)  
Mobita Median (IQR): `r median(SNR_central_m)`(`r IQR(SNR_central_m)`)  
Wilcoxon: `r SNR_central_wil$statistic`, p-value = `r SNR_central_wil$p.value`, Bonferroni p-value: `r SNR_central_wil$p.value*10`, r = `r SNR_central_es$effsize` (`r SNR_central_es$magnitude`)  
Fligner-Killeen: `r SNR_central_flig$statistic`, p-value = `r SNR_central_flig$p.value`, Bonferroni p-value: `r SNR_central_flig$p.value*10`  
**BF**
```{r BF_ERN_cent}
BF_snr_cent$ttest
```

**Posterior electrodes**  
EasyCap Median (IQR): `r median(SNR_posterior_e)`(`r IQR(SNR_posterior_e)`)  
Mobita Median (IQR): `r median(SNR_posterior_m)`(`r IQR(SNR_posterior_m)`)  
Wilcoxon: `r SNR_posterior_wil$statistic`, p-value = `r SNR_posterior_wil$p.value`, Bonferroni p-value: `r SNR_posterior_wil$p.value*10`, r = `r SNR_posterior_es$effsize` (`r SNR_posterior_es$magnitude`)  
Fligner-Killeen: `r SNR_posterior_flig$statistic`, p-value = `r SNR_posterior_flig$p.value`, Bonferroni p-value: `r SNR_posterior_flig$p.value*10`  
**BF**
```{r BF_ERN_post}
BF_snr_post$ttest
```
  
****** 
  
  
## **Number of trials rejected in artefact rejection**  
```{r trials_N, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE} 
df_trials <- read.csv("pre_processing_data.csv")
```
  
**Response-locked epochs**   
  
```{r trials, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE} 
#response-locked trials are divided to correct and error responses. Sum the number of rejected trials and then use the overall number to report
df_trials$E_rej_resp <- df_trials$E_Rej_CorrEp + df_trials$E_Rej_ErrEp
df_trials$M_rej_resp <- df_trials$M_Rej_CorrEp + df_trials$M_Rej_ErrEp
```
  
Median (IQR) EasyCap: `r median(df_trials$E_rej_resp)`(`r IQR(df_trials$E_rej_resp)`)
Median (IQR) Mobita: `r median(df_trials$M_rej_resp)`(`r IQR(df_trials$M_rej_resp)`)  
  
```{r trials_resp, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE} 
Trial_resp <- wilcox.test(df_trials$E_rej_resp, df_trials$M_rej_resp, paired=TRUE)  
```
  
Wilcoxon: `r Trial_resp$statistic`, p-value = `r Trial_resp$p.value`,  
  
**Stimulus-locked epochs**   
  
Median (IQR) EasyCap: `r median(df_trials$E_Rej_AllEp)`(`r IQR(df_trials$E_Rej_AllEp)`)
Median (IQR) Mobita: `r median(df_trials$M_Rej_AllEp)`(`r IQR(df_trials$M_Rej_AllEp)`)
  
```{r trials_stim, eval=TRUE, echo=FALSE,  warning=FALSE, message=FALSE} 
Trial_stim <- wilcox.test(df_trials$E_Rej_AllEp, df_trials$M_Rej_AllEp, paired=TRUE)  
```
  
Wilcoxon: `r Trial_stim$statistic`, p-value = `r Trial_stim$p.value`, 

